        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits
        -:    0:Graph:/Users/paulcolta/Desktop/GitHub/Assignments_FP/Semester 2/OOP/Lab_5(6)/Lab 6 final/LABFINAL8/cmake-build-debug/CMakeFiles/LABFINAL8.dir/Tests.gcno
        -:    0:Data:/Users/paulcolta/Desktop/GitHub/Assignments_FP/Semester 2/OOP/Lab_5(6)/Lab 6 final/LABFINAL8/cmake-build-debug/CMakeFiles/LABFINAL8.dir/Tests.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ type_traits ---------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_TYPE_TRAITS
        -:   12:#define _LIBCPP_TYPE_TRAITS
        -:   13:
        -:   14:/*
        -:   15:    type_traits synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:    // helper class:
        -:   21:    template <class T, T v> struct integral_constant;
        -:   22:    typedef integral_constant<bool, true>  true_type;   // C++11
        -:   23:    typedef integral_constant<bool, false> false_type;  // C++11
        -:   24:
        -:   25:    template <bool B>                                   // C++14
        -:   26:    using bool_constant = integral_constant<bool, B>;   // C++14
        -:   27:    typedef bool_constant<true> true_type;              // C++14
        -:   28:    typedef bool_constant<false> false_type;            // C++14
        -:   29:
        -:   30:    // helper traits
        -:   31:    template <bool, class T = void> struct enable_if;
        -:   32:    template <bool, class T, class F> struct conditional;
        -:   33:
        -:   34:    // Primary classification traits:
        -:   35:    template <class T> struct is_void;
        -:   36:    template <class T> struct is_null_pointer;  // C++14
        -:   37:    template <class T> struct is_integral;
        -:   38:    template <class T> struct is_floating_point;
        -:   39:    template <class T> struct is_array;
        -:   40:    template <class T> struct is_pointer;
        -:   41:    template <class T> struct is_lvalue_reference;
        -:   42:    template <class T> struct is_rvalue_reference;
        -:   43:    template <class T> struct is_member_object_pointer;
        -:   44:    template <class T> struct is_member_function_pointer;
        -:   45:    template <class T> struct is_enum;
        -:   46:    template <class T> struct is_union;
        -:   47:    template <class T> struct is_class;
        -:   48:    template <class T> struct is_function;
        -:   49:
        -:   50:    // Secondary classification traits:
        -:   51:    template <class T> struct is_reference;
        -:   52:    template <class T> struct is_arithmetic;
        -:   53:    template <class T> struct is_fundamental;
        -:   54:    template <class T> struct is_member_pointer;
        -:   55:    template <class T> struct is_scalar;
        -:   56:    template <class T> struct is_object;
        -:   57:    template <class T> struct is_compound;
        -:   58:
        -:   59:    // Const-volatile properties and transformations:
        -:   60:    template <class T> struct is_const;
        -:   61:    template <class T> struct is_volatile;
        -:   62:    template <class T> struct remove_const;
        -:   63:    template <class T> struct remove_volatile;
        -:   64:    template <class T> struct remove_cv;
        -:   65:    template <class T> struct add_const;
        -:   66:    template <class T> struct add_volatile;
        -:   67:    template <class T> struct add_cv;
        -:   68:
        -:   69:    // Reference transformations:
        -:   70:    template <class T> struct remove_reference;
        -:   71:    template <class T> struct add_lvalue_reference;
        -:   72:    template <class T> struct add_rvalue_reference;
        -:   73:
        -:   74:    // Pointer transformations:
        -:   75:    template <class T> struct remove_pointer;
        -:   76:    template <class T> struct add_pointer;
        -:   77:
        -:   78:    template<class T> struct type_identity;                     // C++20
        -:   79:    template<class T>
        -:   80:      using type_identity_t = typename type_identity<T>::type;  // C++20
        -:   81:
        -:   82:    // Integral properties:
        -:   83:    template <class T> struct is_signed;
        -:   84:    template <class T> struct is_unsigned;
        -:   85:    template <class T> struct make_signed;
        -:   86:    template <class T> struct make_unsigned;
        -:   87:
        -:   88:    // Array properties and transformations:
        -:   89:    template <class T> struct rank;
        -:   90:    template <class T, unsigned I = 0> struct extent;
        -:   91:    template <class T> struct remove_extent;
        -:   92:    template <class T> struct remove_all_extents;
        -:   93:
        -:   94:    // Member introspection:
        -:   95:    template <class T> struct is_pod;
        -:   96:    template <class T> struct is_trivial;
        -:   97:    template <class T> struct is_trivially_copyable;
        -:   98:    template <class T> struct is_standard_layout;
        -:   99:    template <class T> struct is_literal_type;
        -:  100:    template <class T> struct is_empty;
        -:  101:    template <class T> struct is_polymorphic;
        -:  102:    template <class T> struct is_abstract;
        -:  103:    template <class T> struct is_final; // C++14
        -:  104:    template <class T> struct is_aggregate; // C++17
        -:  105:
        -:  106:    template <class T, class... Args> struct is_constructible;
        -:  107:    template <class T>                struct is_default_constructible;
        -:  108:    template <class T>                struct is_copy_constructible;
        -:  109:    template <class T>                struct is_move_constructible;
        -:  110:    template <class T, class U>       struct is_assignable;
        -:  111:    template <class T>                struct is_copy_assignable;
        -:  112:    template <class T>                struct is_move_assignable;
        -:  113:    template <class T, class U>       struct is_swappable_with;       // C++17
        -:  114:    template <class T>                struct is_swappable;            // C++17
        -:  115:    template <class T>                struct is_destructible;
        -:  116:
        -:  117:    template <class T, class... Args> struct is_trivially_constructible;
        -:  118:    template <class T>                struct is_trivially_default_constructible;
        -:  119:    template <class T>                struct is_trivially_copy_constructible;
        -:  120:    template <class T>                struct is_trivially_move_constructible;
        -:  121:    template <class T, class U>       struct is_trivially_assignable;
        -:  122:    template <class T>                struct is_trivially_copy_assignable;
        -:  123:    template <class T>                struct is_trivially_move_assignable;
        -:  124:    template <class T>                struct is_trivially_destructible;
        -:  125:
        -:  126:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  127:    template <class T>                struct is_nothrow_default_constructible;
        -:  128:    template <class T>                struct is_nothrow_copy_constructible;
        -:  129:    template <class T>                struct is_nothrow_move_constructible;
        -:  130:    template <class T, class U>       struct is_nothrow_assignable;
        -:  131:    template <class T>                struct is_nothrow_copy_assignable;
        -:  132:    template <class T>                struct is_nothrow_move_assignable;
        -:  133:    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
        -:  134:    template <class T>                struct is_nothrow_swappable;      // C++17
        -:  135:    template <class T>                struct is_nothrow_destructible;
        -:  136:
        -:  137:    template <class T> struct has_virtual_destructor;
        -:  138:
        -:  139:    template<class T> struct has_unique_object_representations;         // C++17
        -:  140:
        -:  141:    // Relationships between types:
        -:  142:    template <class T, class U> struct is_same;
        -:  143:    template <class Base, class Derived> struct is_base_of;
        -:  144:    template <class From, class To> struct is_convertible;
        -:  145:
        -:  146:    template <class Fn, class... ArgTypes> struct is_invocable;
        -:  147:    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;
        -:  148:
        -:  149:    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
        -:  150:    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
        -:  151:
        -:  152:    // Alignment properties and transformations:
        -:  153:    template <class T> struct alignment_of;
        -:  154:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  155:        struct aligned_storage;
        -:  156:    template <size_t Len, class... Types> struct aligned_union;
        -:  157:    template <class T> struct remove_cvref; // C++20
        -:  158:
        -:  159:    template <class T> struct decay;
        -:  160:    template <class... T> struct common_type;
        -:  161:    template <class T> struct underlying_type;
        -:  162:    template <class> class result_of; // undefined
        -:  163:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
        -:  164:    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17
        -:  165:
        -:  166:    // const-volatile modifications:
        -:  167:    template <class T>
        -:  168:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  169:    template <class T>
        -:  170:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  171:    template <class T>
        -:  172:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  173:    template <class T>
        -:  174:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  175:    template <class T>
        -:  176:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  177:    template <class T>
        -:  178:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  179:
        -:  180:    // reference modifications:
        -:  181:    template <class T>
        -:  182:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  183:    template <class T>
        -:  184:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  185:    template <class T>
        -:  186:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  187:
        -:  188:    // sign modifications:
        -:  189:    template <class T>
        -:  190:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  191:    template <class T>
        -:  192:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  193:
        -:  194:    // array modifications:
        -:  195:    template <class T>
        -:  196:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  197:    template <class T>
        -:  198:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  199:
        -:  200:    // pointer modifications:
        -:  201:    template <class T>
        -:  202:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  203:    template <class T>
        -:  204:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  205:
        -:  206:    // other transformations:
        -:  207:    template <size_t Len, std::size_t Align=default-alignment>
        -:  208:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  209:    template <std::size_t Len, class... Types>
        -:  210:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  211:    template <class T>
        -:  212:      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20
        -:  213:    template <class T>
        -:  214:      using decay_t           = typename decay<T>::type;  // C++14
        -:  215:    template <bool b, class T=void>
        -:  216:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  217:    template <bool b, class T, class F>
        -:  218:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  219:    template <class... T>
        -:  220:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  221:    template <class T>
        -:  222:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  223:    template <class T>
        -:  224:      using result_of_t       = typename result_of<T>::type;  // C++14
        -:  225:    template <class Fn, class... ArgTypes>
        -:  226:      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17
        -:  227:
        -:  228:    template <class...>
        -:  229:      using void_t = void;   // C++17
        -:  230:
        -:  231:      // See C++14 20.10.4.1, primary type categories
        -:  232:      template <class T> inline constexpr bool is_void_v
        -:  233:        = is_void<T>::value;                                             // C++17
        -:  234:      template <class T> inline constexpr bool is_null_pointer_v
        -:  235:        = is_null_pointer<T>::value;                                     // C++17
        -:  236:      template <class T> inline constexpr bool is_integral_v
        -:  237:        = is_integral<T>::value;                                         // C++17
        -:  238:      template <class T> inline constexpr bool is_floating_point_v
        -:  239:        = is_floating_point<T>::value;                                   // C++17
        -:  240:      template <class T> inline constexpr bool is_array_v
        -:  241:        = is_array<T>::value;                                            // C++17
        -:  242:      template <class T> inline constexpr bool is_pointer_v
        -:  243:        = is_pointer<T>::value;                                          // C++17
        -:  244:      template <class T> inline constexpr bool is_lvalue_reference_v
        -:  245:        = is_lvalue_reference<T>::value;                                 // C++17
        -:  246:      template <class T> inline constexpr bool is_rvalue_reference_v
        -:  247:        = is_rvalue_reference<T>::value;                                 // C++17
        -:  248:      template <class T> inline constexpr bool is_member_object_pointer_v
        -:  249:        = is_member_object_pointer<T>::value;                            // C++17
        -:  250:      template <class T> inline constexpr bool is_member_function_pointer_v
        -:  251:        = is_member_function_pointer<T>::value;                          // C++17
        -:  252:      template <class T> inline constexpr bool is_enum_v
        -:  253:        = is_enum<T>::value;                                             // C++17
        -:  254:      template <class T> inline constexpr bool is_union_v
        -:  255:        = is_union<T>::value;                                            // C++17
        -:  256:      template <class T> inline constexpr bool is_class_v
        -:  257:        = is_class<T>::value;                                            // C++17
        -:  258:      template <class T> inline constexpr bool is_function_v
        -:  259:        = is_function<T>::value;                                         // C++17
        -:  260:
        -:  261:      // See C++14 20.10.4.2, composite type categories
        -:  262:      template <class T> inline constexpr bool is_reference_v
        -:  263:        = is_reference<T>::value;                                        // C++17
        -:  264:      template <class T> inline constexpr bool is_arithmetic_v
        -:  265:        = is_arithmetic<T>::value;                                       // C++17
        -:  266:      template <class T> inline constexpr bool is_fundamental_v
        -:  267:        = is_fundamental<T>::value;                                      // C++17
        -:  268:      template <class T> inline constexpr bool is_object_v
        -:  269:        = is_object<T>::value;                                           // C++17
        -:  270:      template <class T> inline constexpr bool is_scalar_v
        -:  271:        = is_scalar<T>::value;                                           // C++17
        -:  272:      template <class T> inline constexpr bool is_compound_v
        -:  273:        = is_compound<T>::value;                                         // C++17
        -:  274:      template <class T> inline constexpr bool is_member_pointer_v
        -:  275:        = is_member_pointer<T>::value;                                   // C++17
        -:  276:
        -:  277:      // See C++14 20.10.4.3, type properties
        -:  278:      template <class T> inline constexpr bool is_const_v
        -:  279:        = is_const<T>::value;                                            // C++17
        -:  280:      template <class T> inline constexpr bool is_volatile_v
        -:  281:        = is_volatile<T>::value;                                         // C++17
        -:  282:      template <class T> inline constexpr bool is_trivial_v
        -:  283:        = is_trivial<T>::value;                                          // C++17
        -:  284:      template <class T> inline constexpr bool is_trivially_copyable_v
        -:  285:        = is_trivially_copyable<T>::value;                               // C++17
        -:  286:      template <class T> inline constexpr bool is_standard_layout_v
        -:  287:        = is_standard_layout<T>::value;                                  // C++17
        -:  288:      template <class T> inline constexpr bool is_pod_v
        -:  289:        = is_pod<T>::value;                                              // C++17
        -:  290:      template <class T> inline constexpr bool is_literal_type_v
        -:  291:        = is_literal_type<T>::value;                                     // C++17
        -:  292:      template <class T> inline constexpr bool is_empty_v
        -:  293:        = is_empty<T>::value;                                            // C++17
        -:  294:      template <class T> inline constexpr bool is_polymorphic_v
        -:  295:        = is_polymorphic<T>::value;                                      // C++17
        -:  296:      template <class T> inline constexpr bool is_abstract_v
        -:  297:        = is_abstract<T>::value;                                         // C++17
        -:  298:      template <class T> inline constexpr bool is_final_v
        -:  299:        = is_final<T>::value;                                            // C++17
        -:  300:      template <class T> inline constexpr bool is_aggregate_v
        -:  301:        = is_aggregate<T>::value;                                        // C++17
        -:  302:      template <class T> inline constexpr bool is_signed_v
        -:  303:        = is_signed<T>::value;                                           // C++17
        -:  304:      template <class T> inline constexpr bool is_unsigned_v
        -:  305:        = is_unsigned<T>::value;                                         // C++17
        -:  306:      template <class T, class... Args> inline constexpr bool is_constructible_v
        -:  307:        = is_constructible<T, Args...>::value;                           // C++17
        -:  308:      template <class T> inline constexpr bool is_default_constructible_v
        -:  309:        = is_default_constructible<T>::value;                            // C++17
        -:  310:      template <class T> inline constexpr bool is_copy_constructible_v
        -:  311:        = is_copy_constructible<T>::value;                               // C++17
        -:  312:      template <class T> inline constexpr bool is_move_constructible_v
        -:  313:        = is_move_constructible<T>::value;                               // C++17
        -:  314:      template <class T, class U> inline constexpr bool is_assignable_v
        -:  315:        = is_assignable<T, U>::value;                                    // C++17
        -:  316:      template <class T> inline constexpr bool is_copy_assignable_v
        -:  317:        = is_copy_assignable<T>::value;                                  // C++17
        -:  318:      template <class T> inline constexpr bool is_move_assignable_v
        -:  319:        = is_move_assignable<T>::value;                                  // C++17
        -:  320:      template <class T, class U> inline constexpr bool is_swappable_with_v
        -:  321:        = is_swappable_with<T, U>::value;                                // C++17
        -:  322:      template <class T> inline constexpr bool is_swappable_v
        -:  323:        = is_swappable<T>::value;                                        // C++17
        -:  324:      template <class T> inline constexpr bool is_destructible_v
        -:  325:        = is_destructible<T>::value;                                     // C++17
        -:  326:      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
        -:  327:        = is_trivially_constructible<T, Args...>::value;                 // C++17
        -:  328:      template <class T> inline constexpr bool is_trivially_default_constructible_v
        -:  329:        = is_trivially_default_constructible<T>::value;                  // C++17
        -:  330:      template <class T> inline constexpr bool is_trivially_copy_constructible_v
        -:  331:        = is_trivially_copy_constructible<T>::value;                     // C++17
        -:  332:      template <class T> inline constexpr bool is_trivially_move_constructible_v
        -:  333:        = is_trivially_move_constructible<T>::value;                     // C++17
        -:  334:      template <class T, class U> inline constexpr bool is_trivially_assignable_v
        -:  335:        = is_trivially_assignable<T, U>::value;                          // C++17
        -:  336:      template <class T> inline constexpr bool is_trivially_copy_assignable_v
        -:  337:        = is_trivially_copy_assignable<T>::value;                        // C++17
        -:  338:      template <class T> inline constexpr bool is_trivially_move_assignable_v
        -:  339:        = is_trivially_move_assignable<T>::value;                        // C++17
        -:  340:      template <class T> inline constexpr bool is_trivially_destructible_v
        -:  341:        = is_trivially_destructible<T>::value;                           // C++17
        -:  342:      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
        -:  343:        = is_nothrow_constructible<T, Args...>::value;                   // C++17
        -:  344:      template <class T> inline constexpr bool is_nothrow_default_constructible_v
        -:  345:        = is_nothrow_default_constructible<T>::value;                    // C++17
        -:  346:      template <class T> inline constexpr bool is_nothrow_copy_constructible_v
        -:  347:        = is_nothrow_copy_constructible<T>::value;                       // C++17
        -:  348:      template <class T> inline constexpr bool is_nothrow_move_constructible_v
        -:  349:        = is_nothrow_move_constructible<T>::value;                       // C++17
        -:  350:      template <class T, class U> inline constexpr bool is_nothrow_assignable_v
        -:  351:        = is_nothrow_assignable<T, U>::value;                            // C++17
        -:  352:      template <class T> inline constexpr bool is_nothrow_copy_assignable_v
        -:  353:        = is_nothrow_copy_assignable<T>::value;                          // C++17
        -:  354:      template <class T> inline constexpr bool is_nothrow_move_assignable_v
        -:  355:        = is_nothrow_move_assignable<T>::value;                          // C++17
        -:  356:      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
        -:  357:        = is_nothrow_swappable_with<T, U>::value;                       // C++17
        -:  358:      template <class T> inline constexpr bool is_nothrow_swappable_v
        -:  359:        = is_nothrow_swappable<T>::value;                               // C++17
        -:  360:      template <class T> inline constexpr bool is_nothrow_destructible_v
        -:  361:        = is_nothrow_destructible<T>::value;                             // C++17
        -:  362:      template <class T> inline constexpr bool has_virtual_destructor_v
        -:  363:        = has_virtual_destructor<T>::value;                              // C++17
        -:  364:      template<class T> inline constexpr bool has_unique_object_representations_v // C++17
        -:  365:        = has_unique_object_representations<T>::value;
        -:  366:
        -:  367:      // See C++14 20.10.5, type property queries
        -:  368:      template <class T> inline constexpr size_t alignment_of_v
        -:  369:        = alignment_of<T>::value;                                        // C++17
        -:  370:      template <class T> inline constexpr size_t rank_v
        -:  371:        = rank<T>::value;                                                // C++17
        -:  372:      template <class T, unsigned I = 0> inline constexpr size_t extent_v
        -:  373:        = extent<T, I>::value;                                           // C++17
        -:  374:
        -:  375:      // See C++14 20.10.6, type relations
        -:  376:      template <class T, class U> inline constexpr bool is_same_v
        -:  377:        = is_same<T, U>::value;                                          // C++17
        -:  378:      template <class Base, class Derived> inline constexpr bool is_base_of_v
        -:  379:        = is_base_of<Base, Derived>::value;                              // C++17
        -:  380:      template <class From, class To> inline constexpr bool is_convertible_v
        -:  381:        = is_convertible<From, To>::value;                               // C++17
        -:  382:      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v
        -:  383:        = is_invocable<Fn, ArgTypes...>::value;                          // C++17
        -:  384:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v
        -:  385:        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17
        -:  386:      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v
        -:  387:        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17
        -:  388:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v
        -:  389:        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17
        -:  390:
        -:  391:      // [meta.logical], logical operator traits:
        -:  392:      template<class... B> struct conjunction;                           // C++17
        -:  393:      template<class... B>
        -:  394:        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17
        -:  395:      template<class... B> struct disjunction;                           // C++17
        -:  396:      template<class... B>
        -:  397:        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17
        -:  398:      template<class B> struct negation;                                 // C++17
        -:  399:      template<class B>
        -:  400:        inline constexpr bool negation_v = negation<B>::value;           // C++17
        -:  401:
        -:  402:}
        -:  403:
        -:  404:*/
        -:  405:#include <__config>
        -:  406:#include <cstddef>
        -:  407:#include <__cxx_version>
        -:  408:
        -:  409:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  410:#pragma GCC system_header
        -:  411:#endif
        -:  412:
        -:  413:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  414:
        -:  415:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
        -:  416:template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
        -:  417:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
        -:  418:
        -:  419:template <class>
        -:  420:struct __void_t { typedef void type; };
        -:  421:
        -:  422:template <class _Tp>
        -:  423:struct __identity { typedef _Tp type; };
        -:  424:
        -:  425:template <class _Tp, bool>
        -:  426:struct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};
        -:  427:
        -:  428:template <bool _Bp, class _If, class _Then>
        -:  429:    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};
        -:  430:template <class _If, class _Then>
        -:  431:    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};
        -:  432:
        -:  433:#if _LIBCPP_STD_VER > 11
        -:  434:template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
        -:  435:#endif
        -:  436:
        -:  437:template <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};
        -:  438:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
        -:  439:
        -:  440:template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
        -:  441:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};
        -:  442:
        -:  443:#if _LIBCPP_STD_VER > 11
        -:  444:template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
        -:  445:#endif
        -:  446:
        -:  447:// addressof
        -:  448:#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
        -:  449:
        -:  450:template <class _Tp>
        -:  451:inline _LIBCPP_CONSTEXPR_AFTER_CXX14
        -:  452:_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
        -:  453:_Tp*
        -:  454:addressof(_Tp& __x) _NOEXCEPT
        -:  455:{
        -:  456:    return __builtin_addressof(__x);
        -:  457:}
        -:  458:
        -:  459:#else
        -:  460:
        -:  461:template <class _Tp>
        -:  462:inline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
        -:  463:_Tp*
        -:  464:addressof(_Tp& __x) _NOEXCEPT
        -:  465:{
        -:  466:  return reinterpret_cast<_Tp *>(
        -:  467:      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));
        -:  468:}
        -:  469:
        -:  470:#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
        -:  471:
        -:  472:#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)
        -:  473:// Objective-C++ Automatic Reference Counting uses qualified pointers
        -:  474:// that require special addressof() signatures. When
        -:  475:// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler
        -:  476:// itself is providing these definitions. Otherwise, we provide them.
        -:  477:template <class _Tp>
        -:  478:inline _LIBCPP_INLINE_VISIBILITY
        -:  479:__strong _Tp*
        -:  480:addressof(__strong _Tp& __x) _NOEXCEPT
        -:  481:{
        -:  482:  return &__x;
        -:  483:}
        -:  484:
        -:  485:#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
        -:  486:template <class _Tp>
        -:  487:inline _LIBCPP_INLINE_VISIBILITY
        -:  488:__weak _Tp*
        -:  489:addressof(__weak _Tp& __x) _NOEXCEPT
        -:  490:{
        -:  491:  return &__x;
        -:  492:}
        -:  493:#endif
        -:  494:
        -:  495:template <class _Tp>
        -:  496:inline _LIBCPP_INLINE_VISIBILITY
        -:  497:__autoreleasing _Tp*
        -:  498:addressof(__autoreleasing _Tp& __x) _NOEXCEPT
        -:  499:{
        -:  500:  return &__x;
        -:  501:}
        -:  502:
        -:  503:template <class _Tp>
        -:  504:inline _LIBCPP_INLINE_VISIBILITY
        -:  505:__unsafe_unretained _Tp*
        -:  506:addressof(__unsafe_unretained _Tp& __x) _NOEXCEPT
        -:  507:{
        -:  508:  return &__x;
        -:  509:}
        -:  510:#endif
        -:  511:
        -:  512:#if !defined(_LIBCPP_CXX03_LANG)
        -:  513:template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
        -:  514:#endif
        -:  515:
        -:  516:struct __two {char __lx[2];};
        -:  517:
        -:  518:// helper class:
        -:  519:
        -:  520:template <class _Tp, _Tp __v>
        -:  521:struct _LIBCPP_TEMPLATE_VIS integral_constant
        -:  522:{
        -:  523:    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
        -:  524:    typedef _Tp               value_type;
        -:  525:    typedef integral_constant type;
        -:  526:    _LIBCPP_INLINE_VISIBILITY
        -:  527:        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
        -:  528:#if _LIBCPP_STD_VER > 11
        -:  529:    _LIBCPP_INLINE_VISIBILITY
        -:  530:         constexpr value_type operator ()() const _NOEXCEPT {return value;}
        -:  531:#endif
        -:  532:};
        -:  533:
        -:  534:template <class _Tp, _Tp __v>
        -:  535:_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
        -:  536:
        -:  537:#if _LIBCPP_STD_VER > 14
        -:  538:template <bool __b>
        -:  539:using bool_constant = integral_constant<bool, __b>;
        -:  540:#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
        -:  541:#else
        -:  542:#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
        -:  543:#endif
        -:  544:
        -:  545:typedef _LIBCPP_BOOL_CONSTANT(true)  true_type;
        -:  546:typedef _LIBCPP_BOOL_CONSTANT(false) false_type;
        -:  547:
        -:  548:#if !defined(_LIBCPP_CXX03_LANG)
        -:  549:
        -:  550:// __lazy_and
        -:  551:
        -:  552:template <bool _Last, class ..._Preds>
        -:  553:struct __lazy_and_impl;
        -:  554:
        -:  555:template <class ..._Preds>
        -:  556:struct __lazy_and_impl<false, _Preds...> : false_type {};
        -:  557:
        -:  558:template <>
        -:  559:struct __lazy_and_impl<true> : true_type {};
        -:  560:
        -:  561:template <class _Pred>
        -:  562:struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};
        -:  563:
        -:  564:template <class _Hp, class ..._Tp>
        -:  565:struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};
        -:  566:
        -:  567:template <class _P1, class ..._Pr>
        -:  568:struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};
        -:  569:
        -:  570:// __lazy_or
        -:  571:
        -:  572:template <bool _List, class ..._Preds>
        -:  573:struct __lazy_or_impl;
        -:  574:
        -:  575:template <class ..._Preds>
        -:  576:struct __lazy_or_impl<true, _Preds...> : true_type {};
        -:  577:
        -:  578:template <>
        -:  579:struct __lazy_or_impl<false> : false_type {};
        -:  580:
        -:  581:template <class _Hp, class ..._Tp>
        -:  582:struct __lazy_or_impl<false, _Hp, _Tp...>
        -:  583:        : __lazy_or_impl<_Hp::type::value, _Tp...> {};
        -:  584:
        -:  585:template <class _P1, class ..._Pr>
        -:  586:struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};
        -:  587:
        -:  588:// __lazy_not
        -:  589:
        -:  590:template <class _Pred>
        -:  591:struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};
        -:  592:
        -:  593:// __and_
        -:  594:template<class...> struct __and_;
        -:  595:template<> struct __and_<> : true_type {};
        -:  596:
        -:  597:template<class _B0> struct __and_<_B0> : _B0 {};
        -:  598:
        -:  599:template<class _B0, class _B1>
        -:  600:struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};
        -:  601:
        -:  602:template<class _B0, class _B1, class _B2, class... _Bn>
        -:  603:struct __and_<_B0, _B1, _B2, _Bn...>
        -:  604:        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};
        -:  605:
        -:  606:// __or_
        -:  607:template<class...> struct __or_;
        -:  608:template<> struct __or_<> : false_type {};
        -:  609:
        -:  610:template<class _B0> struct __or_<_B0> : _B0 {};
        -:  611:
        -:  612:template<class _B0, class _B1>
        -:  613:struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};
        -:  614:
        -:  615:template<class _B0, class _B1, class _B2, class... _Bn>
        -:  616:struct __or_<_B0, _B1, _B2, _Bn...>
        -:  617:        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};
        -:  618:
        -:  619:// __not_
        -:  620:template<class _Tp>
        -:  621:struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};
        -:  622:
        -:  623:#endif // !defined(_LIBCPP_CXX03_LANG)
        -:  624:
        -:  625:// is_const
        -:  626:
        -:  627:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};
        -:  628:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};
        -:  629:
        -:  630:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  631:template <class _Tp>
        -:  632:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v
        -:  633:    = is_const<_Tp>::value;
        -:  634:#endif
        -:  635:
        -:  636:// is_volatile
        -:  637:
        -:  638:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};
        -:  639:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};
        -:  640:
        -:  641:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  642:template <class _Tp>
        -:  643:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v
        -:  644:    = is_volatile<_Tp>::value;
        -:  645:#endif
        -:  646:
        -:  647:// remove_const
        -:  648:
        -:  649:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};
        -:  650:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};
        -:  651:#if _LIBCPP_STD_VER > 11
        -:  652:template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
        -:  653:#endif
        -:  654:
        -:  655:// remove_volatile
        -:  656:
        -:  657:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};
        -:  658:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};
        -:  659:#if _LIBCPP_STD_VER > 11
        -:  660:template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
        -:  661:#endif
        -:  662:
        -:  663:// remove_cv
        -:  664:
        -:  665:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv
        -:  666:{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
        -:  667:#if _LIBCPP_STD_VER > 11
        -:  668:template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
        -:  669:#endif
        -:  670:
        -:  671:// is_void
        -:  672:
        -:  673:template <class _Tp> struct __libcpp_is_void       : public false_type {};
        -:  674:template <>          struct __libcpp_is_void<void> : public true_type {};
        -:  675:
        -:  676:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void
        -:  677:    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
        -:  678:
        -:  679:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  680:template <class _Tp>
        -:  681:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v
        -:  682:    = is_void<_Tp>::value;
        -:  683:#endif
        -:  684:
        -:  685:// __is_nullptr_t
        -:  686:
        -:  687:template <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
        -:  688:template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
        -:  689:
        -:  690:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t
        -:  691:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  692:
        -:  693:#if _LIBCPP_STD_VER > 11
        -:  694:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer
        -:  695:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  696:
        -:  697:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  698:template <class _Tp>
        -:  699:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_null_pointer_v
        -:  700:    = is_null_pointer<_Tp>::value;
        -:  701:#endif
        -:  702:#endif
        -:  703:
        -:  704:// is_integral
        -:  705:
        -:  706:template <class _Tp> struct __libcpp_is_integral                     : public false_type {};
        -:  707:template <>          struct __libcpp_is_integral<bool>               : public true_type {};
        -:  708:template <>          struct __libcpp_is_integral<char>               : public true_type {};
        -:  709:template <>          struct __libcpp_is_integral<signed char>        : public true_type {};
        -:  710:template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
        -:  711:template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
        -:  712:#ifndef _LIBCPP_NO_HAS_CHAR8_T
        -:  713:template <>          struct __libcpp_is_integral<char8_t>            : public true_type {};
        -:  714:#endif
        -:  715:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  716:template <>          struct __libcpp_is_integral<char16_t>           : public true_type {};
        -:  717:template <>          struct __libcpp_is_integral<char32_t>           : public true_type {};
        -:  718:#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  719:template <>          struct __libcpp_is_integral<short>              : public true_type {};
        -:  720:template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
        -:  721:template <>          struct __libcpp_is_integral<int>                : public true_type {};
        -:  722:template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
        -:  723:template <>          struct __libcpp_is_integral<long>               : public true_type {};
        -:  724:template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
        -:  725:template <>          struct __libcpp_is_integral<long long>          : public true_type {};
        -:  726:template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};
        -:  727:#ifndef _LIBCPP_HAS_NO_INT128
        -:  728:template <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};
        -:  729:template <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};
        -:  730:#endif
        -:  731:
        -:  732:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral
        -:  733:    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
        -:  734:
        -:  735:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  736:template <class _Tp>
        -:  737:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v
        -:  738:    = is_integral<_Tp>::value;
        -:  739:#endif
        -:  740:
        -:  741:// is_floating_point
        -:  742:
        -:  743:template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
        -:  744:template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
        -:  745:template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
        -:  746:template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
        -:  747:
        -:  748:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point
        -:  749:    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
        -:  750:
        -:  751:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  752:template <class _Tp>
        -:  753:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_floating_point_v
        -:  754:    = is_floating_point<_Tp>::value;
        -:  755:#endif
        -:  756:
        -:  757:// is_array
        -:  758:
        -:  759:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array
        -:  760:    : public false_type {};
        -:  761:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>
        -:  762:    : public true_type {};
        -:  763:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>
        -:  764:    : public true_type {};
        -:  765:
        -:  766:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  767:template <class _Tp>
        -:  768:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v
        -:  769:    = is_array<_Tp>::value;
        -:  770:#endif
        -:  771:
        -:  772:// is_pointer
        -:  773:
        -:  774:template <class _Tp> struct __libcpp_is_pointer       : public false_type {};
        -:  775:template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
        -:  776:
        -:  777:template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };
        -:  778:#if defined(_LIBCPP_HAS_OBJC_ARC)
        -:  779:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __strong> { typedef _Tp type; };
        -:  780:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __weak> { typedef _Tp type; };
        -:  781:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __autoreleasing> { typedef _Tp type; };
        -:  782:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __unsafe_unretained> { typedef _Tp type; };
        -:  783:#endif
        -:  784:
        -:  785:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer
        -:  786:    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};
        -:  787:
        -:  788:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  789:template <class _Tp>
        -:  790:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v
        -:  791:    = is_pointer<_Tp>::value;
        -:  792:#endif
        -:  793:
        -:  794:// is_reference
        -:  795:
        -:  796:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};
        -:  797:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};
        -:  798:
        -:  799:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};
        -:  800:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  801:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};
        -:  802:#endif
        -:  803:
        -:  804:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};
        -:  805:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};
        -:  806:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  807:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};
        -:  808:#endif
        -:  809:
        -:  810:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  811:template <class _Tp>
        -:  812:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v
        -:  813:    = is_reference<_Tp>::value;
        -:  814:
        -:  815:template <class _Tp>
        -:  816:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v
        -:  817:    = is_lvalue_reference<_Tp>::value;
        -:  818:
        -:  819:template <class _Tp>
        -:  820:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v
        -:  821:    = is_rvalue_reference<_Tp>::value;
        -:  822:#endif
        -:  823:// is_union
        -:  824:
        -:  825:#if __has_feature(is_union) || (_GNUC_VER >= 403)
        -:  826:
        -:  827:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
        -:  828:    : public integral_constant<bool, __is_union(_Tp)> {};
        -:  829:
        -:  830:#else
        -:  831:
        -:  832:template <class _Tp> struct __libcpp_union : public false_type {};
        -:  833:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
        -:  834:    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
        -:  835:
        -:  836:#endif
        -:  837:
        -:  838:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  839:template <class _Tp>
        -:  840:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_union_v
        -:  841:    = is_union<_Tp>::value;
        -:  842:#endif
        -:  843:
        -:  844:// is_class
        -:  845:
        -:  846:#if __has_feature(is_class) || (_GNUC_VER >= 403)
        -:  847:
        -:  848:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
        -:  849:    : public integral_constant<bool, __is_class(_Tp)> {};
        -:  850:
        -:  851:#else
        -:  852:
        -:  853:namespace __is_class_imp
        -:  854:{
        -:  855:template <class _Tp> char  __test(int _Tp::*);
        -:  856:template <class _Tp> __two __test(...);
        -:  857:}
        -:  858:
        -:  859:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
        -:  860:    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
        -:  861:
        -:  862:#endif
        -:  863:
        -:  864:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  865:template <class _Tp>
        -:  866:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_class_v
        -:  867:    = is_class<_Tp>::value;
        -:  868:#endif
        -:  869:
        -:  870:// is_same
        -:  871:
        -:  872:template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};
        -:  873:template <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};
        -:  874:
        -:  875:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  876:template <class _Tp, class _Up>
        -:  877:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v
        -:  878:    = is_same<_Tp, _Up>::value;
        -:  879:#endif
        -:  880:
        -:  881:// is_function
        -:  882:
        -:  883:namespace __libcpp_is_function_imp
        -:  884:{
        -:  885:struct __dummy_type {};
        -:  886:template <class _Tp> char  __test(_Tp*);
        -:  887:template <class _Tp> char __test(__dummy_type);
        -:  888:template <class _Tp> __two __test(...);
        -:  889:template <class _Tp> _Tp&  __source(int);
        -:  890:template <class _Tp> __dummy_type __source(...);
        -:  891:}
        -:  892:
        -:  893:template <class _Tp, bool = is_class<_Tp>::value ||
        -:  894:                            is_union<_Tp>::value ||
        -:  895:                            is_void<_Tp>::value  ||
        -:  896:                            is_reference<_Tp>::value ||
        -:  897:                            __is_nullptr_t<_Tp>::value >
        -:  898:struct __libcpp_is_function
        -:  899:    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
        -:  900:    {};
        -:  901:template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
        -:  902:
        -:  903:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function
        -:  904:    : public __libcpp_is_function<_Tp> {};
        -:  905:
        -:  906:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  907:template <class _Tp>
        -:  908:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_function_v
        -:  909:    = is_function<_Tp>::value;
        -:  910:#endif
        -:  911:
        -:  912:// is_member_function_pointer
        -:  913:
        -:  914:// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
        -:  915:// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
        -:  916://
        -:  917:
        -:  918:template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
        -:  919:struct __member_pointer_traits_imp
        -:  920:{  // forward declaration; specializations later
        -:  921:};
        -:  922:
        -:  923:
        -:  924:template <class _Tp> struct __libcpp_is_member_function_pointer
        -:  925:    : public false_type {};
        -:  926:
        -:  927:template <class _Ret, class _Class>
        -:  928:struct __libcpp_is_member_function_pointer<_Ret _Class::*>
        -:  929:    : public is_function<_Ret> {};
        -:  930:
        -:  931:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer
        -:  932:    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
        -:  933:
        -:  934:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  935:template <class _Tp>
        -:  936:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v
        -:  937:    = is_member_function_pointer<_Tp>::value;
        -:  938:#endif
        -:  939:
        -:  940:// is_member_pointer
        -:  941:
        -:  942:template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
        -:  943:template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
        -:  944:
        -:  945:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer
        -:  946:    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
        -:  947:
        -:  948:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  949:template <class _Tp>
        -:  950:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v
        -:  951:    = is_member_pointer<_Tp>::value;
        -:  952:#endif
        -:  953:
        -:  954:// is_member_object_pointer
        -:  955:
        -:  956:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer
        -:  957:    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
        -:  958:                                    !is_member_function_pointer<_Tp>::value> {};
        -:  959:
        -:  960:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  961:template <class _Tp>
        -:  962:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v
        -:  963:    = is_member_object_pointer<_Tp>::value;
        -:  964:#endif
        -:  965:
        -:  966:// is_enum
        -:  967:
        -:  968:#if __has_feature(is_enum) || (_GNUC_VER >= 403)
        -:  969:
        -:  970:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
        -:  971:    : public integral_constant<bool, __is_enum(_Tp)> {};
        -:  972:
        -:  973:#else
        -:  974:
        -:  975:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
        -:  976:    : public integral_constant<bool, !is_void<_Tp>::value             &&
        -:  977:                                     !is_integral<_Tp>::value         &&
        -:  978:                                     !is_floating_point<_Tp>::value   &&
        -:  979:                                     !is_array<_Tp>::value            &&
        -:  980:                                     !is_pointer<_Tp>::value          &&
        -:  981:                                     !is_reference<_Tp>::value        &&
        -:  982:                                     !is_member_pointer<_Tp>::value   &&
        -:  983:                                     !is_union<_Tp>::value            &&
        -:  984:                                     !is_class<_Tp>::value            &&
        -:  985:                                     !is_function<_Tp>::value         > {};
        -:  986:
        -:  987:#endif
        -:  988:
        -:  989:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  990:template <class _Tp>
        -:  991:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v
        -:  992:    = is_enum<_Tp>::value;
        -:  993:#endif
        -:  994:
        -:  995:// is_arithmetic
        -:  996:
        -:  997:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic
        -:  998:    : public integral_constant<bool, is_integral<_Tp>::value      ||
        -:  999:                                     is_floating_point<_Tp>::value> {};
        -: 1000:
        -: 1001:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1002:template <class _Tp>
        -: 1003:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_arithmetic_v
        -: 1004:    = is_arithmetic<_Tp>::value;
        -: 1005:#endif
        -: 1006:
        -: 1007:// is_fundamental
        -: 1008:
        -: 1009:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental
        -: 1010:    : public integral_constant<bool, is_void<_Tp>::value        ||
        -: 1011:                                     __is_nullptr_t<_Tp>::value ||
        -: 1012:                                     is_arithmetic<_Tp>::value> {};
        -: 1013:
        -: 1014:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1015:template <class _Tp>
        -: 1016:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v
        -: 1017:    = is_fundamental<_Tp>::value;
        -: 1018:#endif
        -: 1019:
        -: 1020:// is_scalar
        -: 1021:
        -: 1022:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar
        -: 1023:    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
        -: 1024:                                     is_member_pointer<_Tp>::value ||
        -: 1025:                                     is_pointer<_Tp>::value        ||
        -: 1026:                                     __is_nullptr_t<_Tp>::value    ||
        -: 1027:                                     is_enum<_Tp>::value           > {};
        -: 1028:
        -: 1029:template <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};
        -: 1030:
        -: 1031:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1032:template <class _Tp>
        -: 1033:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v
        -: 1034:    = is_scalar<_Tp>::value;
        -: 1035:#endif
        -: 1036:
        -: 1037:// is_object
        -: 1038:
        -: 1039:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object
        -: 1040:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 1041:                                     is_array<_Tp>::value  ||
        -: 1042:                                     is_union<_Tp>::value  ||
        -: 1043:                                     is_class<_Tp>::value  > {};
        -: 1044:
        -: 1045:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1046:template <class _Tp>
        -: 1047:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v
        -: 1048:    = is_object<_Tp>::value;
        -: 1049:#endif
        -: 1050:
        -: 1051:// is_compound
        -: 1052:
        -: 1053:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound
        -: 1054:    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
        -: 1055:
        -: 1056:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1057:template <class _Tp>
        -: 1058:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v
        -: 1059:    = is_compound<_Tp>::value;
        -: 1060:#endif
        -: 1061:
        -: 1062:
        -: 1063:// __is_referenceable  [defns.referenceable]
        -: 1064:
        -: 1065:struct __is_referenceable_impl {
        -: 1066:    template <class _Tp> static _Tp& __test(int);
        -: 1067:    template <class _Tp> static __two __test(...);
        -: 1068:};
        -: 1069:
        -: 1070:template <class _Tp>
        -: 1071:struct __is_referenceable : integral_constant<bool,
        -: 1072:    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
        -: 1073:
        -: 1074:
        -: 1075:// add_const
        -: 1076:
        -: 1077:template <class _Tp, bool = is_reference<_Tp>::value ||
        -: 1078:                            is_function<_Tp>::value  ||
        -: 1079:                            is_const<_Tp>::value     >
        -: 1080:struct __add_const             {typedef _Tp type;};
        -: 1081:
        -: 1082:template <class _Tp>
        -: 1083:struct __add_const<_Tp, false> {typedef const _Tp type;};
        -: 1084:
        -: 1085:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const
        -: 1086:    {typedef typename __add_const<_Tp>::type type;};
        -: 1087:
        -: 1088:#if _LIBCPP_STD_VER > 11
        -: 1089:template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
        -: 1090:#endif
        -: 1091:
        -: 1092:// add_volatile
        -: 1093:
        -: 1094:template <class _Tp, bool = is_reference<_Tp>::value ||
        -: 1095:                            is_function<_Tp>::value  ||
        -: 1096:                            is_volatile<_Tp>::value  >
        -: 1097:struct __add_volatile             {typedef _Tp type;};
        -: 1098:
        -: 1099:template <class _Tp>
        -: 1100:struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
        -: 1101:
        -: 1102:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile
        -: 1103:    {typedef typename __add_volatile<_Tp>::type type;};
        -: 1104:
        -: 1105:#if _LIBCPP_STD_VER > 11
        -: 1106:template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
        -: 1107:#endif
        -: 1108:
        -: 1109:// add_cv
        -: 1110:
        -: 1111:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv
        -: 1112:    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
        -: 1113:
        -: 1114:#if _LIBCPP_STD_VER > 11
        -: 1115:template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
        -: 1116:#endif
        -: 1117:
        -: 1118:// remove_reference
        -: 1119:
        -: 1120:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};
        -: 1121:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};
        -: 1122:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1123:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};
        -: 1124:#endif
        -: 1125:
        -: 1126:#if _LIBCPP_STD_VER > 11
        -: 1127:template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
        -: 1128:#endif
        -: 1129:
        -: 1130:// add_lvalue_reference
        -: 1131:
        -: 1132:template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };
        -: 1133:template <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };
        -: 1134:
        -: 1135:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference
        -: 1136:{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};
        -: 1137:
        -: 1138:#if _LIBCPP_STD_VER > 11
        -: 1139:template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
        -: 1140:#endif
        -: 1141:
        -: 1142:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1143:
        -: 1144:template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };
        -: 1145:template <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };
        -: 1146:
        -: 1147:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference
        -: 1148:{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
        -: 1149:
        -: 1150:#if _LIBCPP_STD_VER > 11
        -: 1151:template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
        -: 1152:#endif
        -: 1153:
        -: 1154:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1155:
        -: 1156:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1157:
        -: 1158:template <class _Tp> _Tp&& __declval(int);
        -: 1159:template <class _Tp> _Tp   __declval(long);
        -: 1160:
        -: 1161:template <class _Tp>
        -: 1162:decltype(_VSTD::__declval<_Tp>(0))
        -: 1163:declval() _NOEXCEPT;
        -: 1164:
        -: 1165:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1166:
        -: 1167:template <class _Tp>
        -: 1168:typename add_lvalue_reference<_Tp>::type
        -: 1169:declval();
        -: 1170:
        -: 1171:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1172:
        -: 1173:// __uncvref
        -: 1174:
        -: 1175:template <class _Tp>
        -: 1176:struct __uncvref  {
        -: 1177:    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
        -: 1178:};
        -: 1179:
        -: 1180:template <class _Tp>
        -: 1181:struct __unconstref {
        -: 1182:    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
        -: 1183:};
        -: 1184:
        -: 1185:#ifndef _LIBCPP_CXX03_LANG
        -: 1186:template <class _Tp>
        -: 1187:using __uncvref_t = typename __uncvref<_Tp>::type;
        -: 1188:#endif
        -: 1189:
        -: 1190:// __is_same_uncvref
        -: 1191:
        -: 1192:template <class _Tp, class _Up>
        -: 1193:struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
        -: 1194:                                   typename __uncvref<_Up>::type> {};
        -: 1195:
        -: 1196:#if _LIBCPP_STD_VER > 17
        -: 1197:// remove_cvref - same as __uncvref
        -: 1198:template <class _Tp>
        -: 1199:struct remove_cvref : public __uncvref<_Tp> {};
        -: 1200:
        -: 1201:template <class _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;
        -: 1202:#endif
        -: 1203:
        -: 1204:
        -: 1205:struct __any
        -: 1206:{
        -: 1207:    __any(...);
        -: 1208:};
        -: 1209:
        -: 1210:// remove_pointer
        -: 1211:
        -: 1212:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};
        -: 1213:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};
        -: 1214:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};
        -: 1215:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};
        -: 1216:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};
        -: 1217:
        -: 1218:#if _LIBCPP_STD_VER > 11
        -: 1219:template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
        -: 1220:#endif
        -: 1221:
        -: 1222:// add_pointer
        -: 1223:
        -: 1224:template <class _Tp,
        -: 1225:        bool = __is_referenceable<_Tp>::value ||
        -: 1226:                is_same<typename remove_cv<_Tp>::type, void>::value>
        -: 1227:struct __add_pointer_impl
        -: 1228:    {typedef typename remove_reference<_Tp>::type* type;};
        -: 1229:template <class _Tp> struct __add_pointer_impl<_Tp, false>
        -: 1230:    {typedef _Tp type;};
        -: 1231:
        -: 1232:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer
        -: 1233:    {typedef typename __add_pointer_impl<_Tp>::type type;};
        -: 1234:
        -: 1235:#if _LIBCPP_STD_VER > 11
        -: 1236:template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
        -: 1237:#endif
        -: 1238:
        -: 1239:// type_identity
        -: 1240:#if _LIBCPP_STD_VER > 17
        -: 1241:template<class _Tp> struct type_identity { typedef _Tp type; };
        -: 1242:template<class _Tp> using type_identity_t = typename type_identity<_Tp>::type;
        -: 1243:#endif
        -: 1244:
        -: 1245:// is_signed
        -: 1246:
        -: 1247:template <class _Tp, bool = is_integral<_Tp>::value>
        -: 1248:struct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};
        -: 1249:
        -: 1250:template <class _Tp>
        -: 1251:struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
        -: 1252:
        -: 1253:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -: 1254:struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
        -: 1255:
        -: 1256:template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
        -: 1257:
        -: 1258:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};
        -: 1259:
        -: 1260:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1261:template <class _Tp>
        -: 1262:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v
        -: 1263:    = is_signed<_Tp>::value;
        -: 1264:#endif
        -: 1265:
        -: 1266:// is_unsigned
        -: 1267:
        -: 1268:template <class _Tp, bool = is_integral<_Tp>::value>
        -: 1269:struct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};
        -: 1270:
        -: 1271:template <class _Tp>
        -: 1272:struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
        -: 1273:
        -: 1274:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -: 1275:struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
        -: 1276:
        -: 1277:template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
        -: 1278:
        -: 1279:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};
        -: 1280:
        -: 1281:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1282:template <class _Tp>
        -: 1283:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v
        -: 1284:    = is_unsigned<_Tp>::value;
        -: 1285:#endif
        -: 1286:
        -: 1287:// rank
        -: 1288:
        -: 1289:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank
        -: 1290:    : public integral_constant<size_t, 0> {};
        -: 1291:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>
        -: 1292:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -: 1293:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>
        -: 1294:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -: 1295:
        -: 1296:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1297:template <class _Tp>
        -: 1298:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t rank_v
        -: 1299:    = rank<_Tp>::value;
        -: 1300:#endif
        -: 1301:
        -: 1302:// extent
        -: 1303:
        -: 1304:template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent
        -: 1305:    : public integral_constant<size_t, 0> {};
        -: 1306:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>
        -: 1307:    : public integral_constant<size_t, 0> {};
        -: 1308:template <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>
        -: 1309:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -: 1310:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>
        -: 1311:    : public integral_constant<size_t, _Np> {};
        -: 1312:template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>
        -: 1313:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -: 1314:
        -: 1315:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1316:template <class _Tp, unsigned _Ip = 0>
        -: 1317:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v
        -: 1318:    = extent<_Tp, _Ip>::value;
        -: 1319:#endif
        -: 1320:
        -: 1321:// remove_extent
        -: 1322:
        -: 1323:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent
        -: 1324:    {typedef _Tp type;};
        -: 1325:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>
        -: 1326:    {typedef _Tp type;};
        -: 1327:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>
        -: 1328:    {typedef _Tp type;};
        -: 1329:
        -: 1330:#if _LIBCPP_STD_VER > 11
        -: 1331:template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
        -: 1332:#endif
        -: 1333:
        -: 1334:// remove_all_extents
        -: 1335:
        -: 1336:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents
        -: 1337:    {typedef _Tp type;};
        -: 1338:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>
        -: 1339:    {typedef typename remove_all_extents<_Tp>::type type;};
        -: 1340:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>
        -: 1341:    {typedef typename remove_all_extents<_Tp>::type type;};
        -: 1342:
        -: 1343:#if _LIBCPP_STD_VER > 11
        -: 1344:template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
        -: 1345:#endif
        -: 1346:
        -: 1347:// decay
        -: 1348:
        -: 1349:template <class _Up, bool>
        -: 1350:struct __decay {
        -: 1351:    typedef typename remove_cv<_Up>::type type;
        -: 1352:};
        -: 1353:
        -: 1354:template <class _Up>
        -: 1355:struct __decay<_Up, true> {
        -: 1356:public:
        -: 1357:    typedef typename conditional
        -: 1358:                     <
        -: 1359:                         is_array<_Up>::value,
        -: 1360:                         typename remove_extent<_Up>::type*,
        -: 1361:                         typename conditional
        -: 1362:                         <
        -: 1363:                              is_function<_Up>::value,
        -: 1364:                              typename add_pointer<_Up>::type,
        -: 1365:                              typename remove_cv<_Up>::type
        -: 1366:                         >::type
        -: 1367:                     >::type type;
        -: 1368:};
        -: 1369:
        -: 1370:template <class _Tp>
        -: 1371:struct _LIBCPP_TEMPLATE_VIS decay
        -: 1372:{
        -: 1373:private:
        -: 1374:    typedef typename remove_reference<_Tp>::type _Up;
        -: 1375:public:
        -: 1376:    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        -: 1377:};
        -: 1378:
        -: 1379:#if _LIBCPP_STD_VER > 11
        -: 1380:template <class _Tp> using decay_t = typename decay<_Tp>::type;
        -: 1381:#endif
        -: 1382:
        -: 1383:// is_abstract
        -: 1384:
        -: 1385:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract
        -: 1386:    : public integral_constant<bool, __is_abstract(_Tp)> {};
        -: 1387:
        -: 1388:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1389:template <class _Tp>
        -: 1390:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_abstract_v
        -: 1391:    = is_abstract<_Tp>::value;
        -: 1392:#endif
        -: 1393:
        -: 1394:// is_final
        -: 1395:
        -: 1396:#if defined(_LIBCPP_HAS_IS_FINAL)
        -: 1397:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1398:__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -: 1399:#else
        -: 1400:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1401:__libcpp_is_final : public false_type {};
        -: 1402:#endif
        -: 1403:
        -: 1404:#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11
        -: 1405:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1406:is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -: 1407:#endif
        -: 1408:
        -: 1409:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1410:template <class _Tp>
        -: 1411:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_final_v
        -: 1412:    = is_final<_Tp>::value;
        -: 1413:#endif
        -: 1414:
        -: 1415:// is_aggregate
        -: 1416:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
        -: 1417:
        -: 1418:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1419:is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};
        -: 1420:
        -: 1421:#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1422:template <class _Tp>
        -: 1423:_LIBCPP_INLINE_VAR constexpr bool is_aggregate_v
        -: 1424:    = is_aggregate<_Tp>::value;
        -: 1425:#endif
        -: 1426:
        -: 1427:#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
        -: 1428:
        -: 1429:// is_base_of
        -: 1430:
        -: 1431:#ifdef _LIBCPP_HAS_IS_BASE_OF
        -: 1432:
        -: 1433:template <class _Bp, class _Dp>
        -: 1434:struct _LIBCPP_TEMPLATE_VIS is_base_of
        -: 1435:    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
        -: 1436:
        -: 1437:#else  // _LIBCPP_HAS_IS_BASE_OF
        -: 1438:
        -: 1439:namespace __is_base_of_imp
        -: 1440:{
        -: 1441:template <class _Tp>
        -: 1442:struct _Dst
        -: 1443:{
        -: 1444:    _Dst(const volatile _Tp &);
        -: 1445:};
        -: 1446:template <class _Tp>
        -: 1447:struct _Src
        -: 1448:{
        -: 1449:    operator const volatile _Tp &();
        -: 1450:    template <class _Up> operator const _Dst<_Up> &();
        -: 1451:};
        -: 1452:template <size_t> struct __one { typedef char type; };
        -: 1453:template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
        -: 1454:template <class _Bp, class _Dp> __two __test(...);
        -: 1455:}
        -: 1456:
        -: 1457:template <class _Bp, class _Dp>
        -: 1458:struct _LIBCPP_TEMPLATE_VIS is_base_of
        -: 1459:    : public integral_constant<bool, is_class<_Bp>::value &&
        -: 1460:                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
        -: 1461:
        -: 1462:#endif  // _LIBCPP_HAS_IS_BASE_OF
        -: 1463:
        -: 1464:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1465:template <class _Bp, class _Dp>
        -: 1466:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_base_of_v
        -: 1467:    = is_base_of<_Bp, _Dp>::value;
        -: 1468:#endif
        -: 1469:
        -: 1470:// is_convertible
        -: 1471:
        -: 1472:#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
        -: 1473:
        -: 1474:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
        -: 1475:    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
        -: 1476:                                     !is_abstract<_T2>::value> {};
        -: 1477:
        -: 1478:#else  // __has_feature(is_convertible_to)
        -: 1479:
        -: 1480:namespace __is_convertible_imp
        -: 1481:{
        -: 1482:template <class _Tp> void  __test_convert(_Tp);
        -: 1483:
        -: 1484:template <class _From, class _To, class = void>
        -: 1485:struct __is_convertible_test : public false_type {};
        -: 1486:
        -: 1487:template <class _From, class _To>
        -: 1488:struct __is_convertible_test<_From, _To,
        -: 1489:    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type
        -: 1490:{};
        -: 1491:
        -: 1492:template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
        -: 1493:                     bool _IsFunction = is_function<_Tp>::value,
        -: 1494:                     bool _IsVoid =     is_void<_Tp>::value>
        -: 1495:                     struct __is_array_function_or_void                          {enum {value = 0};};
        -: 1496:template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
        -: 1497:template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
        -: 1498:template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
        -: 1499:}
        -: 1500:
        -: 1501:template <class _Tp,
        -: 1502:    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
        -: 1503:struct __is_convertible_check
        -: 1504:{
        -: 1505:    static const size_t __v = 0;
        -: 1506:};
        -: 1507:
        -: 1508:template <class _Tp>
        -: 1509:struct __is_convertible_check<_Tp, 0>
        -: 1510:{
        -: 1511:    static const size_t __v = sizeof(_Tp);
        -: 1512:};
        -: 1513:
        -: 1514:template <class _T1, class _T2,
        -: 1515:    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
        -: 1516:    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
        -: 1517:struct __is_convertible
        -: 1518:    : public integral_constant<bool,
        -: 1519:        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
        -: 1520:#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
        -: 1521:         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
        -: 1522:              && (!is_const<typename remove_reference<_T2>::type>::value
        -: 1523:                  || is_volatile<typename remove_reference<_T2>::type>::value)
        -: 1524:                  && (is_same<typename remove_cv<_T1>::type,
        -: 1525:                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
        -: 1526:                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
        -: 1527:#endif
        -: 1528:    >
        -: 1529:{};
        -: 1530:
        -: 1531:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
        -: 1532:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
        -: 1533:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
        -: 1534:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
        -: 1535:
        -: 1536:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
        -: 1537:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
        -: 1538:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
        -: 1539:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
        -: 1540:
        -: 1541:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
        -: 1542:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
        -: 1543:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
        -: 1544:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
        -: 1545:
        -: 1546:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
        -: 1547:    : public __is_convertible<_T1, _T2>
        -: 1548:{
        -: 1549:    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
        -: 1550:    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
        -: 1551:};
        -: 1552:
        -: 1553:#endif  // __has_feature(is_convertible_to)
        -: 1554:
        -: 1555:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1556:template <class _From, class _To>
        -: 1557:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_convertible_v
        -: 1558:    = is_convertible<_From, _To>::value;
        -: 1559:#endif
        -: 1560:
        -: 1561:// is_empty
        -: 1562:
        -: 1563:#if __has_feature(is_empty) || (_GNUC_VER >= 407)
        -: 1564:
        -: 1565:template <class _Tp>
        -: 1566:struct _LIBCPP_TEMPLATE_VIS is_empty
        -: 1567:    : public integral_constant<bool, __is_empty(_Tp)> {};
        -: 1568:
        -: 1569:#else  // __has_feature(is_empty)
        -: 1570:
        -: 1571:template <class _Tp>
        -: 1572:struct __is_empty1
        -: 1573:    : public _Tp
        -: 1574:{
        -: 1575:    double __lx;
        -: 1576:};
        -: 1577:
        -: 1578:struct __is_empty2
        -: 1579:{
        -: 1580:    double __lx;
        -: 1581:};
        -: 1582:
        -: 1583:template <class _Tp, bool = is_class<_Tp>::value>
        -: 1584:struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
        -: 1585:
        -: 1586:template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
        -: 1587:
        -: 1588:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};
        -: 1589:
        -: 1590:#endif  // __has_feature(is_empty)
        -: 1591:
        -: 1592:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1593:template <class _Tp>
        -: 1594:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_empty_v
        -: 1595:    = is_empty<_Tp>::value;
        -: 1596:#endif
        -: 1597:
        -: 1598:// is_polymorphic
        -: 1599:
        -: 1600:#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)
        -: 1601:
        -: 1602:template <class _Tp>
        -: 1603:struct _LIBCPP_TEMPLATE_VIS is_polymorphic
        -: 1604:    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
        -: 1605:
        -: 1606:#else
        -: 1607:
        -: 1608:template<typename _Tp> char &__is_polymorphic_impl(
        -: 1609:    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
        -: 1610:                       int>::type);
        -: 1611:template<typename _Tp> __two &__is_polymorphic_impl(...);
        -: 1612:
        -: 1613:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic
        -: 1614:    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
        -: 1615:
        -: 1616:#endif // __has_feature(is_polymorphic)
        -: 1617:
        -: 1618:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1619:template <class _Tp>
        -: 1620:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_polymorphic_v
        -: 1621:    = is_polymorphic<_Tp>::value;
        -: 1622:#endif
        -: 1623:
        -: 1624:// has_virtual_destructor
        -: 1625:
        -: 1626:#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
        -: 1627:
        -: 1628:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
        -: 1629:    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
        -: 1630:
        -: 1631:#else
        -: 1632:
        -: 1633:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
        -: 1634:    : public false_type {};
        -: 1635:
        -: 1636:#endif
        -: 1637:
        -: 1638:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1639:template <class _Tp>
        -: 1640:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_virtual_destructor_v
        -: 1641:    = has_virtual_destructor<_Tp>::value;
        -: 1642:#endif
        -: 1643:
        -: 1644:// has_unique_object_representations
        -: 1645:
        -: 1646:#if _LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)
        -: 1647:
        -: 1648:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_unique_object_representations
        -: 1649:    : public integral_constant<bool,
        -: 1650:       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};
        -: 1651:
        -: 1652:#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1653:template <class _Tp>
        -: 1654:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_unique_object_representations_v
        -: 1655:    = has_unique_object_representations<_Tp>::value;
        -: 1656:#endif
        -: 1657:
        -: 1658:#endif
        -: 1659:
        -: 1660:// alignment_of
        -: 1661:
        -: 1662:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of
        -: 1663:    : public integral_constant<size_t, _LIBCPP_ALIGNOF(_Tp)> {};
        -: 1664:
        -: 1665:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1666:template <class _Tp>
        -: 1667:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t alignment_of_v
        -: 1668:    = alignment_of<_Tp>::value;
        -: 1669:#endif
        -: 1670:
        -: 1671:// aligned_storage
        -: 1672:
        -: 1673:template <class _Hp, class _Tp>
        -: 1674:struct __type_list
        -: 1675:{
        -: 1676:    typedef _Hp _Head;
        -: 1677:    typedef _Tp _Tail;
        -: 1678:};
        -: 1679:
        -: 1680:struct __nat
        -: 1681:{
        -: 1682:#ifndef _LIBCPP_CXX03_LANG
        -: 1683:    __nat() = delete;
        -: 1684:    __nat(const __nat&) = delete;
        -: 1685:    __nat& operator=(const __nat&) = delete;
        -: 1686:    ~__nat() = delete;
        -: 1687:#endif
        -: 1688:};
        -: 1689:
        -: 1690:template <class _Tp>
        -: 1691:struct __align_type
        -: 1692:{
        -: 1693:    static const size_t value = _LIBCPP_PREFERRED_ALIGNOF(_Tp);
        -: 1694:    typedef _Tp type;
        -: 1695:};
        -: 1696:
        -: 1697:struct __struct_double {long double __lx;};
        -: 1698:struct __struct_double4 {double __lx[4];};
        -: 1699:
        -: 1700:typedef
        -: 1701:    __type_list<__align_type<unsigned char>,
        -: 1702:    __type_list<__align_type<unsigned short>,
        -: 1703:    __type_list<__align_type<unsigned int>,
        -: 1704:    __type_list<__align_type<unsigned long>,
        -: 1705:    __type_list<__align_type<unsigned long long>,
        -: 1706:    __type_list<__align_type<double>,
        -: 1707:    __type_list<__align_type<long double>,
        -: 1708:    __type_list<__align_type<__struct_double>,
        -: 1709:    __type_list<__align_type<__struct_double4>,
        -: 1710:    __type_list<__align_type<int*>,
        -: 1711:    __nat
        -: 1712:    > > > > > > > > > > __all_types;
        -: 1713:
        -: 1714:template <class _TL, size_t _Align> struct __find_pod;
        -: 1715:
        -: 1716:template <class _Hp, size_t _Align>
        -: 1717:struct __find_pod<__type_list<_Hp, __nat>, _Align>
        -: 1718:{
        -: 1719:    typedef typename conditional<
        -: 1720:                             _Align == _Hp::value,
        -: 1721:                             typename _Hp::type,
        -: 1722:                             void
        -: 1723:                         >::type type;
        -: 1724:};
        -: 1725:
        -: 1726:template <class _Hp, class _Tp, size_t _Align>
        -: 1727:struct __find_pod<__type_list<_Hp, _Tp>, _Align>
        -: 1728:{
        -: 1729:    typedef typename conditional<
        -: 1730:                             _Align == _Hp::value,
        -: 1731:                             typename _Hp::type,
        -: 1732:                             typename __find_pod<_Tp, _Align>::type
        -: 1733:                         >::type type;
        -: 1734:};
        -: 1735:
        -: 1736:template <class _TL, size_t _Len> struct __find_max_align;
        -: 1737:
        -: 1738:template <class _Hp, size_t _Len>
        -: 1739:struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
        -: 1740:
        -: 1741:template <size_t _Len, size_t _A1, size_t _A2>
        -: 1742:struct __select_align
        -: 1743:{
        -: 1744:private:
        -: 1745:    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        -: 1746:    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        -: 1747:public:
        -: 1748:    static const size_t value = _Len < __max ? __min : __max;
        -: 1749:};
        -: 1750:
        -: 1751:template <class _Hp, class _Tp, size_t _Len>
        -: 1752:struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        -: 1753:    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
        -: 1754:
        -: 1755:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1756:struct _LIBCPP_TEMPLATE_VIS aligned_storage
        -: 1757:{
        -: 1758:    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        -: 1759:    static_assert(!is_void<_Aligner>::value, "");
        -: 1760:    union type
        -: 1761:    {
        -: 1762:        _Aligner __align;
        -: 1763:        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
        -: 1764:    };
        -: 1765:};
        -: 1766:
        -: 1767:#if _LIBCPP_STD_VER > 11
        -: 1768:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1769:    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
        -: 1770:#endif
        -: 1771:
        -: 1772:#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
        -: 1773:template <size_t _Len>\
        -: 1774:struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\
        -: 1775:{\
        -: 1776:    struct _ALIGNAS(n) type\
        -: 1777:    {\
        -: 1778:        unsigned char __lx[(_Len + n - 1)/n * n];\
        -: 1779:    };\
        -: 1780:}
        -: 1781:
        -: 1782:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
        -: 1783:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
        -: 1784:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
        -: 1785:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
        -: 1786:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
        -: 1787:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
        -: 1788:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
        -: 1789:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
        -: 1790:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
        -: 1791:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
        -: 1792:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
        -: 1793:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
        -: 1794:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
        -: 1795:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
        -: 1796:// PE/COFF does not support alignment beyond 8192 (=0x2000)
        -: 1797:#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
        -: 1798:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
        -: 1799:#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)
        -: 1800:
        -: 1801:#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
        -: 1802:
        -: 1803:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1804:
        -: 1805:// aligned_union
        -: 1806:
        -: 1807:template <size_t _I0, size_t ..._In>
        -: 1808:struct __static_max;
        -: 1809:
        -: 1810:template <size_t _I0>
        -: 1811:struct __static_max<_I0>
        -: 1812:{
        -: 1813:    static const size_t value = _I0;
        -: 1814:};
        -: 1815:
        -: 1816:template <size_t _I0, size_t _I1, size_t ..._In>
        -: 1817:struct __static_max<_I0, _I1, _In...>
        -: 1818:{
        -: 1819:    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
        -: 1820:                                             __static_max<_I1, _In...>::value;
        -: 1821:};
        -: 1822:
        -: 1823:template <size_t _Len, class _Type0, class ..._Types>
        -: 1824:struct aligned_union
        -: 1825:{
        -: 1826:    static const size_t alignment_value = __static_max<_LIBCPP_PREFERRED_ALIGNOF(_Type0),
        -: 1827:                                                       _LIBCPP_PREFERRED_ALIGNOF(_Types)...>::value;
        -: 1828:    static const size_t __len = __static_max<_Len, sizeof(_Type0),
        -: 1829:                                             sizeof(_Types)...>::value;
        -: 1830:    typedef typename aligned_storage<__len, alignment_value>::type type;
        -: 1831:};
        -: 1832:
        -: 1833:#if _LIBCPP_STD_VER > 11
        -: 1834:template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
        -: 1835:#endif
        -: 1836:
        -: 1837:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1838:
        -: 1839:template <class _Tp>
        -: 1840:struct __numeric_type
        -: 1841:{
        -: 1842:   static void __test(...);
        -: 1843:   static float __test(float);
        -: 1844:   static double __test(char);
        -: 1845:   static double __test(int);
        -: 1846:   static double __test(unsigned);
        -: 1847:   static double __test(long);
        -: 1848:   static double __test(unsigned long);
        -: 1849:   static double __test(long long);
        -: 1850:   static double __test(unsigned long long);
        -: 1851:   static double __test(double);
        -: 1852:   static long double __test(long double);
        -: 1853:
        -: 1854:   typedef decltype(__test(declval<_Tp>())) type;
        -: 1855:   static const bool value = !is_same<type, void>::value;
        -: 1856:};
        -: 1857:
        -: 1858:template <>
        -: 1859:struct __numeric_type<void>
        -: 1860:{
        -: 1861:   static const bool value = true;
        -: 1862:};
        -: 1863:
        -: 1864:// __promote
        -: 1865:
        -: 1866:template <class _A1, class _A2 = void, class _A3 = void,
        -: 1867:          bool = __numeric_type<_A1>::value &&
        -: 1868:                 __numeric_type<_A2>::value &&
        -: 1869:                 __numeric_type<_A3>::value>
        -: 1870:class __promote_imp
        -: 1871:{
        -: 1872:public:
        -: 1873:    static const bool value = false;
        -: 1874:};
        -: 1875:
        -: 1876:template <class _A1, class _A2, class _A3>
        -: 1877:class __promote_imp<_A1, _A2, _A3, true>
        -: 1878:{
        -: 1879:private:
        -: 1880:    typedef typename __promote_imp<_A1>::type __type1;
        -: 1881:    typedef typename __promote_imp<_A2>::type __type2;
        -: 1882:    typedef typename __promote_imp<_A3>::type __type3;
        -: 1883:public:
        -: 1884:    typedef decltype(__type1() + __type2() + __type3()) type;
        -: 1885:    static const bool value = true;
        -: 1886:};
        -: 1887:
        -: 1888:template <class _A1, class _A2>
        -: 1889:class __promote_imp<_A1, _A2, void, true>
        -: 1890:{
        -: 1891:private:
        -: 1892:    typedef typename __promote_imp<_A1>::type __type1;
        -: 1893:    typedef typename __promote_imp<_A2>::type __type2;
        -: 1894:public:
        -: 1895:    typedef decltype(__type1() + __type2()) type;
        -: 1896:    static const bool value = true;
        -: 1897:};
        -: 1898:
        -: 1899:template <class _A1>
        -: 1900:class __promote_imp<_A1, void, void, true>
        -: 1901:{
        -: 1902:public:
        -: 1903:    typedef typename __numeric_type<_A1>::type type;
        -: 1904:    static const bool value = true;
        -: 1905:};
        -: 1906:
        -: 1907:template <class _A1, class _A2 = void, class _A3 = void>
        -: 1908:class __promote : public __promote_imp<_A1, _A2, _A3> {};
        -: 1909:
        -: 1910:// make_signed / make_unsigned
        -: 1911:
        -: 1912:typedef
        -: 1913:    __type_list<signed char,
        -: 1914:    __type_list<signed short,
        -: 1915:    __type_list<signed int,
        -: 1916:    __type_list<signed long,
        -: 1917:    __type_list<signed long long,
        -: 1918:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1919:    __type_list<__int128_t,
        -: 1920:#endif
        -: 1921:    __nat
        -: 1922:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1923:    >
        -: 1924:#endif
        -: 1925:    > > > > > __signed_types;
        -: 1926:
        -: 1927:typedef
        -: 1928:    __type_list<unsigned char,
        -: 1929:    __type_list<unsigned short,
        -: 1930:    __type_list<unsigned int,
        -: 1931:    __type_list<unsigned long,
        -: 1932:    __type_list<unsigned long long,
        -: 1933:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1934:    __type_list<__uint128_t,
        -: 1935:#endif
        -: 1936:    __nat
        -: 1937:#ifndef _LIBCPP_HAS_NO_INT128
        -: 1938:    >
        -: 1939:#endif
        -: 1940:    > > > > > __unsigned_types;
        -: 1941:
        -: 1942:template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        -: 1943:
        -: 1944:template <class _Hp, class _Tp, size_t _Size>
        -: 1945:struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
        -: 1946:{
        -: 1947:    typedef _Hp type;
        -: 1948:};
        -: 1949:
        -: 1950:template <class _Hp, class _Tp, size_t _Size>
        -: 1951:struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
        -: 1952:{
        -: 1953:    typedef typename __find_first<_Tp, _Size>::type type;
        -: 1954:};
        -: 1955:
        -: 1956:template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
        -: 1957:                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
        -: 1958:struct __apply_cv
        -: 1959:{
        -: 1960:    typedef _Up type;
        -: 1961:};
        -: 1962:
        -: 1963:template <class _Tp, class _Up>
        -: 1964:struct __apply_cv<_Tp, _Up, true, false>
        -: 1965:{
        -: 1966:    typedef const _Up type;
        -: 1967:};
        -: 1968:
        -: 1969:template <class _Tp, class _Up>
        -: 1970:struct __apply_cv<_Tp, _Up, false, true>
        -: 1971:{
        -: 1972:    typedef volatile _Up type;
        -: 1973:};
        -: 1974:
        -: 1975:template <class _Tp, class _Up>
        -: 1976:struct __apply_cv<_Tp, _Up, true, true>
        -: 1977:{
        -: 1978:    typedef const volatile _Up type;
        -: 1979:};
        -: 1980:
        -: 1981:template <class _Tp, class _Up>
        -: 1982:struct __apply_cv<_Tp&, _Up, false, false>
        -: 1983:{
        -: 1984:    typedef _Up& type;
        -: 1985:};
        -: 1986:
        -: 1987:template <class _Tp, class _Up>
        -: 1988:struct __apply_cv<_Tp&, _Up, true, false>
        -: 1989:{
        -: 1990:    typedef const _Up& type;
        -: 1991:};
        -: 1992:
        -: 1993:template <class _Tp, class _Up>
        -: 1994:struct __apply_cv<_Tp&, _Up, false, true>
        -: 1995:{
        -: 1996:    typedef volatile _Up& type;
        -: 1997:};
        -: 1998:
        -: 1999:template <class _Tp, class _Up>
        -: 2000:struct __apply_cv<_Tp&, _Up, true, true>
        -: 2001:{
        -: 2002:    typedef const volatile _Up& type;
        -: 2003:};
        -: 2004:
        -: 2005:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 2006:struct __make_signed {};
        -: 2007:
        -: 2008:template <class _Tp>
        -: 2009:struct __make_signed<_Tp, true>
        -: 2010:{
        -: 2011:    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        -: 2012:};
        -: 2013:
        -: 2014:template <> struct __make_signed<bool,               true> {};
        -: 2015:template <> struct __make_signed<  signed short,     true> {typedef short     type;};
        -: 2016:template <> struct __make_signed<unsigned short,     true> {typedef short     type;};
        -: 2017:template <> struct __make_signed<  signed int,       true> {typedef int       type;};
        -: 2018:template <> struct __make_signed<unsigned int,       true> {typedef int       type;};
        -: 2019:template <> struct __make_signed<  signed long,      true> {typedef long      type;};
        -: 2020:template <> struct __make_signed<unsigned long,      true> {typedef long      type;};
        -: 2021:template <> struct __make_signed<  signed long long, true> {typedef long long type;};
        -: 2022:template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
        -: 2023:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2024:template <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
        -: 2025:template <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
        -: 2026:#endif
        -: 2027:
        -: 2028:template <class _Tp>
        -: 2029:struct _LIBCPP_TEMPLATE_VIS make_signed
        -: 2030:{
        -: 2031:    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        -: 2032:};
        -: 2033:
        -: 2034:#if _LIBCPP_STD_VER > 11
        -: 2035:template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
        -: 2036:#endif
        -: 2037:
        -: 2038:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 2039:struct __make_unsigned {};
        -: 2040:
        -: 2041:template <class _Tp>
        -: 2042:struct __make_unsigned<_Tp, true>
        -: 2043:{
        -: 2044:    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        -: 2045:};
        -: 2046:
        -: 2047:template <> struct __make_unsigned<bool,               true> {};
        -: 2048:template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
        -: 2049:template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
        -: 2050:template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
        -: 2051:template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
        -: 2052:template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
        -: 2053:template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
        -: 2054:template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
        -: 2055:template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
        -: 2056:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2057:template <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
        -: 2058:template <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
        -: 2059:#endif
        -: 2060:
        -: 2061:template <class _Tp>
        -: 2062:struct _LIBCPP_TEMPLATE_VIS make_unsigned
        -: 2063:{
        -: 2064:    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        -: 2065:};
        -: 2066:
        -: 2067:#if _LIBCPP_STD_VER > 11
        -: 2068:template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
        -: 2069:#endif
        -: 2070:
        -: 2071:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 2072:
        -: 2073:template <class _Tp, class _Up = void, class _Vp = void>
        -: 2074:struct _LIBCPP_TEMPLATE_VIS common_type
        -: 2075:{
        -: 2076:public:
        -: 2077:    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;
        -: 2078:};
        -: 2079:
        -: 2080:template <>
        -: 2081:struct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>
        -: 2082:{
        -: 2083:public:
        -: 2084:    typedef void type;
        -: 2085:};
        -: 2086:
        -: 2087:template <class _Tp>
        -: 2088:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>
        -: 2089:{
        -: 2090:public:
        -: 2091:    typedef typename common_type<_Tp, _Tp>::type type;
        -: 2092:};
        -: 2093:
        -: 2094:template <class _Tp, class _Up>
        -: 2095:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>
        -: 2096:{
        -: 2097:    typedef typename decay<decltype(
        -: 2098:        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
        -: 2099:      )>::type type;
        -: 2100:};
        -: 2101:
        -: 2102:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2103:
        -: 2104:// bullet 1 - sizeof...(Tp) == 0
        -: 2105:
        -: 2106:template <class ..._Tp>
        -: 2107:struct _LIBCPP_TEMPLATE_VIS common_type {};
        -: 2108:
        -: 2109:// bullet 2 - sizeof...(Tp) == 1
        -: 2110:
        -: 2111:template <class _Tp>
        -: 2112:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp>
        -: 2113:    : public common_type<_Tp, _Tp> {};
        -: 2114:
        -: 2115:// bullet 3 - sizeof...(Tp) == 2
        -: 2116:
        -: 2117:template <class _Tp, class _Up, class = void>
        -: 2118:struct __common_type2_imp {};
        -: 2119:
        -: 2120:template <class _Tp, class _Up>
        -: 2121:struct __common_type2_imp<_Tp, _Up,
        -: 2122:    typename __void_t<decltype(
        -: 2123:        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
        -: 2124:    )>::type>
        -: 2125:{
        -: 2126:    typedef typename decay<decltype(
        -: 2127:        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
        -: 2128:    )>::type type;
        -: 2129:};
        -: 2130:
        -: 2131:template <class _Tp, class _Up,
        -: 2132:          class _DTp = typename decay<_Tp>::type,
        -: 2133:          class _DUp = typename decay<_Up>::type>
        -: 2134:using __common_type2 =
        -: 2135:  typename conditional<
        -: 2136:    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
        -: 2137:    __common_type2_imp<_Tp, _Up>,
        -: 2138:    common_type<_DTp, _DUp>
        -: 2139:  >::type;
        -: 2140:
        -: 2141:template <class _Tp, class _Up>
        -: 2142:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>
        -: 2143:    : __common_type2<_Tp, _Up> {};
        -: 2144:
        -: 2145:// bullet 4 - sizeof...(Tp) > 2
        -: 2146:
        -: 2147:template <class ...Tp> struct __common_types;
        -: 2148:
        -: 2149:template <class, class = void>
        -: 2150:struct __common_type_impl {};
        -: 2151:
        -: 2152:template <class _Tp, class _Up>
        -: 2153:struct __common_type_impl<
        -: 2154:    __common_types<_Tp, _Up>,
        -: 2155:    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
        -: 2156:{
        -: 2157:  typedef typename common_type<_Tp, _Up>::type type;
        -: 2158:};
        -: 2159:
        -: 2160:template <class _Tp, class _Up, class ..._Vp>
        -: 2161:struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
        -: 2162:    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
        -: 2163:  : __common_type_impl<
        -: 2164:      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
        -: 2165:{
        -: 2166:
        -: 2167:};
        -: 2168:
        -: 2169:template <class _Tp, class _Up, class ..._Vp>
        -: 2170:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>
        -: 2171:    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};
        -: 2172:
        -: 2173:#if _LIBCPP_STD_VER > 11
        -: 2174:template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
        -: 2175:#endif
        -: 2176:
        -: 2177:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2178:
        -: 2179:// is_assignable
        -: 2180:
        -: 2181:template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
        -: 2182:
        -: 2183:template <class _Tp, class _Arg>
        -: 2184:typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
        -: 2185:__is_assignable_test(int);
        -: 2186:
        -: 2187:template <class, class>
        -: 2188:false_type __is_assignable_test(...);
        -: 2189:
        -: 2190:
        -: 2191:template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
        -: 2192:struct __is_assignable_imp
        -: 2193:    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};
        -: 2194:
        -: 2195:template <class _Tp, class _Arg>
        -: 2196:struct __is_assignable_imp<_Tp, _Arg, true>
        -: 2197:    : public false_type
        -: 2198:{
        -: 2199:};
        -: 2200:
        -: 2201:template <class _Tp, class _Arg>
        -: 2202:struct is_assignable
        -: 2203:    : public __is_assignable_imp<_Tp, _Arg> {};
        -: 2204:
        -: 2205:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2206:template <class _Tp, class _Arg>
        -: 2207:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v
        -: 2208:    = is_assignable<_Tp, _Arg>::value;
        -: 2209:#endif
        -: 2210:
        -: 2211:// is_copy_assignable
        -: 2212:
        -: 2213:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable
        -: 2214:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2215:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2216:
        -: 2217:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2218:template <class _Tp>
        -: 2219:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_assignable_v
        -: 2220:    = is_copy_assignable<_Tp>::value;
        -: 2221:#endif
        -: 2222:
        -: 2223:// is_move_assignable
        -: 2224:
        -: 2225:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable
        -: 2226:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2227:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2228:                           typename add_rvalue_reference<_Tp>::type> {};
        -: 2229:#else
        -: 2230:    : public is_copy_assignable<_Tp> {};
        -: 2231:#endif
        -: 2232:
        -: 2233:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2234:template <class _Tp>
        -: 2235:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_assignable_v
        -: 2236:    = is_move_assignable<_Tp>::value;
        -: 2237:#endif
        -: 2238:
        -: 2239:// is_destructible
        -: 2240:
        -: 2241://  if it's a reference, return true
        -: 2242://  if it's a function, return false
        -: 2243://  if it's   void,     return false
        -: 2244://  if it's an array of unknown bound, return false
        -: 2245://  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
        -: 2246://    where _Up is remove_all_extents<_Tp>::type
        -: 2247:
        -: 2248:template <class>
        -: 2249:struct __is_destructible_apply { typedef int type; };
        -: 2250:
        -: 2251:template <typename _Tp>
        -: 2252:struct __is_destructor_wellformed {
        -: 2253:    template <typename _Tp1>
        -: 2254:    static char  __test (
        -: 2255:        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
        -: 2256:    );
        -: 2257:
        -: 2258:    template <typename _Tp1>
        -: 2259:    static __two __test (...);
        -: 2260:
        -: 2261:    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
        -: 2262:};
        -: 2263:
        -: 2264:template <class _Tp, bool>
        -: 2265:struct __destructible_imp;
        -: 2266:
        -: 2267:template <class _Tp>
        -: 2268:struct __destructible_imp<_Tp, false>
        -: 2269:   : public _VSTD::integral_constant<bool,
        -: 2270:        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
        -: 2271:
        -: 2272:template <class _Tp>
        -: 2273:struct __destructible_imp<_Tp, true>
        -: 2274:    : public _VSTD::true_type {};
        -: 2275:
        -: 2276:template <class _Tp, bool>
        -: 2277:struct __destructible_false;
        -: 2278:
        -: 2279:template <class _Tp>
        -: 2280:struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
        -: 2281:
        -: 2282:template <class _Tp>
        -: 2283:struct __destructible_false<_Tp, true> : public _VSTD::false_type {};
        -: 2284:
        -: 2285:template <class _Tp>
        -: 2286:struct is_destructible
        -: 2287:    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
        -: 2288:
        -: 2289:template <class _Tp>
        -: 2290:struct is_destructible<_Tp[]>
        -: 2291:    : public _VSTD::false_type {};
        -: 2292:
        -: 2293:template <>
        -: 2294:struct is_destructible<void>
        -: 2295:    : public _VSTD::false_type {};
        -: 2296:
        -: 2297:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2298:template <class _Tp>
        -: 2299:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v
        -: 2300:    = is_destructible<_Tp>::value;
        -: 2301:#endif
        -: 2302:
        -: 2303:// move
        -: 2304:
        -: 2305:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2306:
        -: 2307:template <class _Tp>
        -: 2308:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2309:typename remove_reference<_Tp>::type&&
    #####: 2310:move(_Tp&& __t) _NOEXCEPT
    $$$$$: 2310-block  0
        -: 2311:{
        -: 2312:    typedef typename remove_reference<_Tp>::type _Up;
    #####: 2313:    return static_cast<_Up&&>(__t);
    $$$$$: 2313-block  0
        -: 2314:}
        -: 2315:
        -: 2316:template <class _Tp>
        -: 2317:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2318:_Tp&&
    #####: 2319:forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
    $$$$$: 2319-block  0
    $$$$$: 2319-block  1
        -: 2320:{
    #####: 2321:    return static_cast<_Tp&&>(__t);
    $$$$$: 2321-block  0
    $$$$$: 2321-block  1
        -: 2322:}
        -: 2323:
        -: 2324:template <class _Tp>
        -: 2325:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2326:_Tp&&
        -: 2327:forward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT
        -: 2328:{
        -: 2329:    static_assert(!is_lvalue_reference<_Tp>::value,
        -: 2330:                  "can not forward an rvalue as an lvalue");
        -: 2331:    return static_cast<_Tp&&>(__t);
        -: 2332:}
        -: 2333:
        -: 2334:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2335:
        -: 2336:template <class _Tp>
        -: 2337:inline _LIBCPP_INLINE_VISIBILITY
        -: 2338:_Tp&
        -: 2339:move(_Tp& __t)
        -: 2340:{
        -: 2341:    return __t;
        -: 2342:}
        -: 2343:
        -: 2344:template <class _Tp>
        -: 2345:inline _LIBCPP_INLINE_VISIBILITY
        -: 2346:const _Tp&
        -: 2347:move(const _Tp& __t)
        -: 2348:{
        -: 2349:    return __t;
        -: 2350:}
        -: 2351:
        -: 2352:template <class _Tp>
        -: 2353:inline _LIBCPP_INLINE_VISIBILITY
        -: 2354:_Tp&
        -: 2355:forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 2356:{
        -: 2357:    return __t;
        -: 2358:}
        -: 2359:
        -: 2360:
        -: 2361:template <class _Tp>
        -: 2362:class __rv
        -: 2363:{
        -: 2364:    typedef typename remove_reference<_Tp>::type _Trr;
        -: 2365:    _Trr& t_;
        -: 2366:public:
        -: 2367:    _LIBCPP_INLINE_VISIBILITY
        -: 2368:    _Trr* operator->() {return &t_;}
        -: 2369:    _LIBCPP_INLINE_VISIBILITY
        -: 2370:    explicit __rv(_Trr& __t) : t_(__t) {}
        -: 2371:};
        -: 2372:
        -: 2373:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2374:
        -: 2375:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2376:
        -: 2377:template <class _Tp>
        -: 2378:inline _LIBCPP_INLINE_VISIBILITY
        -: 2379:typename decay<_Tp>::type
        -: 2380:__decay_copy(_Tp&& __t)
        -: 2381:{
        -: 2382:    return _VSTD::forward<_Tp>(__t);
        -: 2383:}
        -: 2384:
        -: 2385:#else
        -: 2386:
        -: 2387:template <class _Tp>
        -: 2388:inline _LIBCPP_INLINE_VISIBILITY
        -: 2389:typename decay<_Tp>::type
        -: 2390:__decay_copy(const _Tp& __t)
        -: 2391:{
        -: 2392:    return _VSTD::forward<_Tp>(__t);
        -: 2393:}
        -: 2394:
        -: 2395:#endif
        -: 2396:
        -: 2397:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2398:
        -: 2399:template <class _Rp, class _Class, class ..._Param>
        -: 2400:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
        -: 2401:{
        -: 2402:    typedef _Class _ClassType;
        -: 2403:    typedef _Rp _ReturnType;
        -: 2404:    typedef _Rp (_FnType) (_Param...);
        -: 2405:};
        -: 2406:
        -: 2407:template <class _Rp, class _Class, class ..._Param>
        -: 2408:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
        -: 2409:{
        -: 2410:    typedef _Class _ClassType;
        -: 2411:    typedef _Rp _ReturnType;
        -: 2412:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2413:};
        -: 2414:
        -: 2415:template <class _Rp, class _Class, class ..._Param>
        -: 2416:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
        -: 2417:{
        -: 2418:    typedef _Class const _ClassType;
        -: 2419:    typedef _Rp _ReturnType;
        -: 2420:    typedef _Rp (_FnType) (_Param...);
        -: 2421:};
        -: 2422:
        -: 2423:template <class _Rp, class _Class, class ..._Param>
        -: 2424:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
        -: 2425:{
        -: 2426:    typedef _Class const _ClassType;
        -: 2427:    typedef _Rp _ReturnType;
        -: 2428:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2429:};
        -: 2430:
        -: 2431:template <class _Rp, class _Class, class ..._Param>
        -: 2432:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
        -: 2433:{
        -: 2434:    typedef _Class volatile _ClassType;
        -: 2435:    typedef _Rp _ReturnType;
        -: 2436:    typedef _Rp (_FnType) (_Param...);
        -: 2437:};
        -: 2438:
        -: 2439:template <class _Rp, class _Class, class ..._Param>
        -: 2440:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
        -: 2441:{
        -: 2442:    typedef _Class volatile _ClassType;
        -: 2443:    typedef _Rp _ReturnType;
        -: 2444:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2445:};
        -: 2446:
        -: 2447:template <class _Rp, class _Class, class ..._Param>
        -: 2448:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
        -: 2449:{
        -: 2450:    typedef _Class const volatile _ClassType;
        -: 2451:    typedef _Rp _ReturnType;
        -: 2452:    typedef _Rp (_FnType) (_Param...);
        -: 2453:};
        -: 2454:
        -: 2455:template <class _Rp, class _Class, class ..._Param>
        -: 2456:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
        -: 2457:{
        -: 2458:    typedef _Class const volatile _ClassType;
        -: 2459:    typedef _Rp _ReturnType;
        -: 2460:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2461:};
        -: 2462:
        -: 2463:#if __has_feature(cxx_reference_qualified_functions) || \
        -: 2464:    (defined(_GNUC_VER) && _GNUC_VER >= 409)
        -: 2465:
        -: 2466:template <class _Rp, class _Class, class ..._Param>
        -: 2467:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
        -: 2468:{
        -: 2469:    typedef _Class& _ClassType;
        -: 2470:    typedef _Rp _ReturnType;
        -: 2471:    typedef _Rp (_FnType) (_Param...);
        -: 2472:};
        -: 2473:
        -: 2474:template <class _Rp, class _Class, class ..._Param>
        -: 2475:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
        -: 2476:{
        -: 2477:    typedef _Class& _ClassType;
        -: 2478:    typedef _Rp _ReturnType;
        -: 2479:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2480:};
        -: 2481:
        -: 2482:template <class _Rp, class _Class, class ..._Param>
        -: 2483:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
        -: 2484:{
        -: 2485:    typedef _Class const& _ClassType;
        -: 2486:    typedef _Rp _ReturnType;
        -: 2487:    typedef _Rp (_FnType) (_Param...);
        -: 2488:};
        -: 2489:
        -: 2490:template <class _Rp, class _Class, class ..._Param>
        -: 2491:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
        -: 2492:{
        -: 2493:    typedef _Class const& _ClassType;
        -: 2494:    typedef _Rp _ReturnType;
        -: 2495:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2496:};
        -: 2497:
        -: 2498:template <class _Rp, class _Class, class ..._Param>
        -: 2499:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
        -: 2500:{
        -: 2501:    typedef _Class volatile& _ClassType;
        -: 2502:    typedef _Rp _ReturnType;
        -: 2503:    typedef _Rp (_FnType) (_Param...);
        -: 2504:};
        -: 2505:
        -: 2506:template <class _Rp, class _Class, class ..._Param>
        -: 2507:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
        -: 2508:{
        -: 2509:    typedef _Class volatile& _ClassType;
        -: 2510:    typedef _Rp _ReturnType;
        -: 2511:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2512:};
        -: 2513:
        -: 2514:template <class _Rp, class _Class, class ..._Param>
        -: 2515:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
        -: 2516:{
        -: 2517:    typedef _Class const volatile& _ClassType;
        -: 2518:    typedef _Rp _ReturnType;
        -: 2519:    typedef _Rp (_FnType) (_Param...);
        -: 2520:};
        -: 2521:
        -: 2522:template <class _Rp, class _Class, class ..._Param>
        -: 2523:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
        -: 2524:{
        -: 2525:    typedef _Class const volatile& _ClassType;
        -: 2526:    typedef _Rp _ReturnType;
        -: 2527:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2528:};
        -: 2529:
        -: 2530:template <class _Rp, class _Class, class ..._Param>
        -: 2531:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
        -: 2532:{
        -: 2533:    typedef _Class&& _ClassType;
        -: 2534:    typedef _Rp _ReturnType;
        -: 2535:    typedef _Rp (_FnType) (_Param...);
        -: 2536:};
        -: 2537:
        -: 2538:template <class _Rp, class _Class, class ..._Param>
        -: 2539:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
        -: 2540:{
        -: 2541:    typedef _Class&& _ClassType;
        -: 2542:    typedef _Rp _ReturnType;
        -: 2543:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2544:};
        -: 2545:
        -: 2546:template <class _Rp, class _Class, class ..._Param>
        -: 2547:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
        -: 2548:{
        -: 2549:    typedef _Class const&& _ClassType;
        -: 2550:    typedef _Rp _ReturnType;
        -: 2551:    typedef _Rp (_FnType) (_Param...);
        -: 2552:};
        -: 2553:
        -: 2554:template <class _Rp, class _Class, class ..._Param>
        -: 2555:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
        -: 2556:{
        -: 2557:    typedef _Class const&& _ClassType;
        -: 2558:    typedef _Rp _ReturnType;
        -: 2559:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2560:};
        -: 2561:
        -: 2562:template <class _Rp, class _Class, class ..._Param>
        -: 2563:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
        -: 2564:{
        -: 2565:    typedef _Class volatile&& _ClassType;
        -: 2566:    typedef _Rp _ReturnType;
        -: 2567:    typedef _Rp (_FnType) (_Param...);
        -: 2568:};
        -: 2569:
        -: 2570:template <class _Rp, class _Class, class ..._Param>
        -: 2571:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
        -: 2572:{
        -: 2573:    typedef _Class volatile&& _ClassType;
        -: 2574:    typedef _Rp _ReturnType;
        -: 2575:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2576:};
        -: 2577:
        -: 2578:template <class _Rp, class _Class, class ..._Param>
        -: 2579:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
        -: 2580:{
        -: 2581:    typedef _Class const volatile&& _ClassType;
        -: 2582:    typedef _Rp _ReturnType;
        -: 2583:    typedef _Rp (_FnType) (_Param...);
        -: 2584:};
        -: 2585:
        -: 2586:template <class _Rp, class _Class, class ..._Param>
        -: 2587:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
        -: 2588:{
        -: 2589:    typedef _Class const volatile&& _ClassType;
        -: 2590:    typedef _Rp _ReturnType;
        -: 2591:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2592:};
        -: 2593:
        -: 2594:#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
        -: 2595:
        -: 2596:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2597:
        -: 2598:template <class _Rp, class _Class>
        -: 2599:struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
        -: 2600:{
        -: 2601:    typedef _Class _ClassType;
        -: 2602:    typedef _Rp _ReturnType;
        -: 2603:    typedef _Rp (_FnType) ();
        -: 2604:};
        -: 2605:
        -: 2606:template <class _Rp, class _Class>
        -: 2607:struct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
        -: 2608:{
        -: 2609:    typedef _Class _ClassType;
        -: 2610:    typedef _Rp _ReturnType;
        -: 2611:    typedef _Rp (_FnType) (...);
        -: 2612:};
        -: 2613:
        -: 2614:template <class _Rp, class _Class, class _P0>
        -: 2615:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
        -: 2616:{
        -: 2617:    typedef _Class _ClassType;
        -: 2618:    typedef _Rp _ReturnType;
        -: 2619:    typedef _Rp (_FnType) (_P0);
        -: 2620:};
        -: 2621:
        -: 2622:template <class _Rp, class _Class, class _P0>
        -: 2623:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
        -: 2624:{
        -: 2625:    typedef _Class _ClassType;
        -: 2626:    typedef _Rp _ReturnType;
        -: 2627:    typedef _Rp (_FnType) (_P0, ...);
        -: 2628:};
        -: 2629:
        -: 2630:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2631:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
        -: 2632:{
        -: 2633:    typedef _Class _ClassType;
        -: 2634:    typedef _Rp _ReturnType;
        -: 2635:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2636:};
        -: 2637:
        -: 2638:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2639:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
        -: 2640:{
        -: 2641:    typedef _Class _ClassType;
        -: 2642:    typedef _Rp _ReturnType;
        -: 2643:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2644:};
        -: 2645:
        -: 2646:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2647:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
        -: 2648:{
        -: 2649:    typedef _Class _ClassType;
        -: 2650:    typedef _Rp _ReturnType;
        -: 2651:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2652:};
        -: 2653:
        -: 2654:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2655:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
        -: 2656:{
        -: 2657:    typedef _Class _ClassType;
        -: 2658:    typedef _Rp _ReturnType;
        -: 2659:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2660:};
        -: 2661:
        -: 2662:template <class _Rp, class _Class>
        -: 2663:struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
        -: 2664:{
        -: 2665:    typedef _Class const _ClassType;
        -: 2666:    typedef _Rp _ReturnType;
        -: 2667:    typedef _Rp (_FnType) ();
        -: 2668:};
        -: 2669:
        -: 2670:template <class _Rp, class _Class>
        -: 2671:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
        -: 2672:{
        -: 2673:    typedef _Class const _ClassType;
        -: 2674:    typedef _Rp _ReturnType;
        -: 2675:    typedef _Rp (_FnType) (...);
        -: 2676:};
        -: 2677:
        -: 2678:template <class _Rp, class _Class, class _P0>
        -: 2679:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
        -: 2680:{
        -: 2681:    typedef _Class const _ClassType;
        -: 2682:    typedef _Rp _ReturnType;
        -: 2683:    typedef _Rp (_FnType) (_P0);
        -: 2684:};
        -: 2685:
        -: 2686:template <class _Rp, class _Class, class _P0>
        -: 2687:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
        -: 2688:{
        -: 2689:    typedef _Class const _ClassType;
        -: 2690:    typedef _Rp _ReturnType;
        -: 2691:    typedef _Rp (_FnType) (_P0, ...);
        -: 2692:};
        -: 2693:
        -: 2694:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2695:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
        -: 2696:{
        -: 2697:    typedef _Class const _ClassType;
        -: 2698:    typedef _Rp _ReturnType;
        -: 2699:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2700:};
        -: 2701:
        -: 2702:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2703:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
        -: 2704:{
        -: 2705:    typedef _Class const _ClassType;
        -: 2706:    typedef _Rp _ReturnType;
        -: 2707:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2708:};
        -: 2709:
        -: 2710:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2711:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
        -: 2712:{
        -: 2713:    typedef _Class const _ClassType;
        -: 2714:    typedef _Rp _ReturnType;
        -: 2715:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2716:};
        -: 2717:
        -: 2718:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2719:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
        -: 2720:{
        -: 2721:    typedef _Class const _ClassType;
        -: 2722:    typedef _Rp _ReturnType;
        -: 2723:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2724:};
        -: 2725:
        -: 2726:template <class _Rp, class _Class>
        -: 2727:struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
        -: 2728:{
        -: 2729:    typedef _Class volatile _ClassType;
        -: 2730:    typedef _Rp _ReturnType;
        -: 2731:    typedef _Rp (_FnType) ();
        -: 2732:};
        -: 2733:
        -: 2734:template <class _Rp, class _Class>
        -: 2735:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
        -: 2736:{
        -: 2737:    typedef _Class volatile _ClassType;
        -: 2738:    typedef _Rp _ReturnType;
        -: 2739:    typedef _Rp (_FnType) (...);
        -: 2740:};
        -: 2741:
        -: 2742:template <class _Rp, class _Class, class _P0>
        -: 2743:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
        -: 2744:{
        -: 2745:    typedef _Class volatile _ClassType;
        -: 2746:    typedef _Rp _ReturnType;
        -: 2747:    typedef _Rp (_FnType) (_P0);
        -: 2748:};
        -: 2749:
        -: 2750:template <class _Rp, class _Class, class _P0>
        -: 2751:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
        -: 2752:{
        -: 2753:    typedef _Class volatile _ClassType;
        -: 2754:    typedef _Rp _ReturnType;
        -: 2755:    typedef _Rp (_FnType) (_P0, ...);
        -: 2756:};
        -: 2757:
        -: 2758:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2759:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
        -: 2760:{
        -: 2761:    typedef _Class volatile _ClassType;
        -: 2762:    typedef _Rp _ReturnType;
        -: 2763:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2764:};
        -: 2765:
        -: 2766:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2767:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
        -: 2768:{
        -: 2769:    typedef _Class volatile _ClassType;
        -: 2770:    typedef _Rp _ReturnType;
        -: 2771:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2772:};
        -: 2773:
        -: 2774:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2775:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
        -: 2776:{
        -: 2777:    typedef _Class volatile _ClassType;
        -: 2778:    typedef _Rp _ReturnType;
        -: 2779:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2780:};
        -: 2781:
        -: 2782:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2783:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
        -: 2784:{
        -: 2785:    typedef _Class volatile _ClassType;
        -: 2786:    typedef _Rp _ReturnType;
        -: 2787:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2788:};
        -: 2789:
        -: 2790:template <class _Rp, class _Class>
        -: 2791:struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
        -: 2792:{
        -: 2793:    typedef _Class const volatile _ClassType;
        -: 2794:    typedef _Rp _ReturnType;
        -: 2795:    typedef _Rp (_FnType) ();
        -: 2796:};
        -: 2797:
        -: 2798:template <class _Rp, class _Class>
        -: 2799:struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
        -: 2800:{
        -: 2801:    typedef _Class const volatile _ClassType;
        -: 2802:    typedef _Rp _ReturnType;
        -: 2803:    typedef _Rp (_FnType) (...);
        -: 2804:};
        -: 2805:
        -: 2806:template <class _Rp, class _Class, class _P0>
        -: 2807:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
        -: 2808:{
        -: 2809:    typedef _Class const volatile _ClassType;
        -: 2810:    typedef _Rp _ReturnType;
        -: 2811:    typedef _Rp (_FnType) (_P0);
        -: 2812:};
        -: 2813:
        -: 2814:template <class _Rp, class _Class, class _P0>
        -: 2815:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
        -: 2816:{
        -: 2817:    typedef _Class const volatile _ClassType;
        -: 2818:    typedef _Rp _ReturnType;
        -: 2819:    typedef _Rp (_FnType) (_P0, ...);
        -: 2820:};
        -: 2821:
        -: 2822:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2823:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
        -: 2824:{
        -: 2825:    typedef _Class const volatile _ClassType;
        -: 2826:    typedef _Rp _ReturnType;
        -: 2827:    typedef _Rp (_FnType) (_P0, _P1);
        -: 2828:};
        -: 2829:
        -: 2830:template <class _Rp, class _Class, class _P0, class _P1>
        -: 2831:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
        -: 2832:{
        -: 2833:    typedef _Class const volatile _ClassType;
        -: 2834:    typedef _Rp _ReturnType;
        -: 2835:    typedef _Rp (_FnType) (_P0, _P1, ...);
        -: 2836:};
        -: 2837:
        -: 2838:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2839:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
        -: 2840:{
        -: 2841:    typedef _Class const volatile _ClassType;
        -: 2842:    typedef _Rp _ReturnType;
        -: 2843:    typedef _Rp (_FnType) (_P0, _P1, _P2);
        -: 2844:};
        -: 2845:
        -: 2846:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 2847:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
        -: 2848:{
        -: 2849:    typedef _Class const volatile _ClassType;
        -: 2850:    typedef _Rp _ReturnType;
        -: 2851:    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
        -: 2852:};
        -: 2853:
        -: 2854:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2855:
        -: 2856:template <class _Rp, class _Class>
        -: 2857:struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
        -: 2858:{
        -: 2859:    typedef _Class _ClassType;
        -: 2860:    typedef _Rp _ReturnType;
        -: 2861:};
        -: 2862:
        -: 2863:template <class _MP>
        -: 2864:struct __member_pointer_traits
        -: 2865:    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
        -: 2866:                    is_member_function_pointer<_MP>::value,
        -: 2867:                    is_member_object_pointer<_MP>::value>
        -: 2868:{
        -: 2869://     typedef ... _ClassType;
        -: 2870://     typedef ... _ReturnType;
        -: 2871://     typedef ... _FnType;
        -: 2872:};
        -: 2873:
        -: 2874:
        -: 2875:template <class _DecayedFp>
        -: 2876:struct __member_pointer_class_type {};
        -: 2877:
        -: 2878:template <class _Ret, class _ClassType>
        -: 2879:struct __member_pointer_class_type<_Ret _ClassType::*> {
        -: 2880:  typedef _ClassType type;
        -: 2881:};
        -: 2882:
        -: 2883:// result_of
        -: 2884:
        -: 2885:template <class _Callable> class result_of;
        -: 2886:
        -: 2887:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 2888:
        -: 2889:template <class _Fn, bool, bool>
        -: 2890:class __result_of
        -: 2891:{
        -: 2892:};
        -: 2893:
        -: 2894:template <class _Fn>
        -: 2895:class __result_of<_Fn(), true, false>
        -: 2896:{
        -: 2897:public:
        -: 2898:    typedef decltype(declval<_Fn>()()) type;
        -: 2899:};
        -: 2900:
        -: 2901:template <class _Fn, class _A0>
        -: 2902:class __result_of<_Fn(_A0), true, false>
        -: 2903:{
        -: 2904:public:
        -: 2905:    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
        -: 2906:};
        -: 2907:
        -: 2908:template <class _Fn, class _A0, class _A1>
        -: 2909:class __result_of<_Fn(_A0, _A1), true, false>
        -: 2910:{
        -: 2911:public:
        -: 2912:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
        -: 2913:};
        -: 2914:
        -: 2915:template <class _Fn, class _A0, class _A1, class _A2>
        -: 2916:class __result_of<_Fn(_A0, _A1, _A2), true, false>
        -: 2917:{
        -: 2918:public:
        -: 2919:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
        -: 2920:};
        -: 2921:
        -: 2922:template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
        -: 2923:struct __result_of_mp;
        -: 2924:
        -: 2925:// member function pointer
        -: 2926:
        -: 2927:template <class _MP, class _Tp>
        -: 2928:struct __result_of_mp<_MP, _Tp, true>
        -: 2929:    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
        -: 2930:{
        -: 2931:};
        -: 2932:
        -: 2933:// member data pointer
        -: 2934:
        -: 2935:template <class _MP, class _Tp, bool>
        -: 2936:struct __result_of_mdp;
        -: 2937:
        -: 2938:template <class _Rp, class _Class, class _Tp>
        -: 2939:struct __result_of_mdp<_Rp _Class::*, _Tp, false>
        -: 2940:{
        -: 2941:    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
        -: 2942:};
        -: 2943:
        -: 2944:template <class _Rp, class _Class, class _Tp>
        -: 2945:struct __result_of_mdp<_Rp _Class::*, _Tp, true>
        -: 2946:{
        -: 2947:    typedef typename __apply_cv<_Tp, _Rp>::type& type;
        -: 2948:};
        -: 2949:
        -: 2950:template <class _Rp, class _Class, class _Tp>
        -: 2951:struct __result_of_mp<_Rp _Class::*, _Tp, false>
        -: 2952:    : public __result_of_mdp<_Rp _Class::*, _Tp,
        -: 2953:            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
        -: 2954:{
        -: 2955:};
        -: 2956:
        -: 2957:
        -: 2958:
        -: 2959:template <class _Fn, class _Tp>
        -: 2960:class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
        -: 2961:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2962:                            _Tp,
        -: 2963:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2964:{
        -: 2965:};
        -: 2966:
        -: 2967:template <class _Fn, class _Tp, class _A0>
        -: 2968:class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
        -: 2969:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2970:                            _Tp,
        -: 2971:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2972:{
        -: 2973:};
        -: 2974:
        -: 2975:template <class _Fn, class _Tp, class _A0, class _A1>
        -: 2976:class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
        -: 2977:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2978:                            _Tp,
        -: 2979:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2980:{
        -: 2981:};
        -: 2982:
        -: 2983:template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
        -: 2984:class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
        -: 2985:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 2986:                            _Tp,
        -: 2987:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 2988:{
        -: 2989:};
        -: 2990:
        -: 2991:// result_of
        -: 2992:
        -: 2993:template <class _Fn>
        -: 2994:class _LIBCPP_TEMPLATE_VIS result_of<_Fn()>
        -: 2995:    : public __result_of<_Fn(),
        -: 2996:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 2997:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 2998:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 2999:                        >
        -: 3000:{
        -: 3001:};
        -: 3002:
        -: 3003:template <class _Fn, class _A0>
        -: 3004:class _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>
        -: 3005:    : public __result_of<_Fn(_A0),
        -: 3006:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 3007:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 3008:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 3009:                        >
        -: 3010:{
        -: 3011:};
        -: 3012:
        -: 3013:template <class _Fn, class _A0, class _A1>
        -: 3014:class _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>
        -: 3015:    : public __result_of<_Fn(_A0, _A1),
        -: 3016:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 3017:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 3018:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 3019:                        >
        -: 3020:{
        -: 3021:};
        -: 3022:
        -: 3023:template <class _Fn, class _A0, class _A1, class _A2>
        -: 3024:class _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>
        -: 3025:    : public __result_of<_Fn(_A0, _A1, _A2),
        -: 3026:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 3027:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 3028:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 3029:                        >
        -: 3030:{
        -: 3031:};
        -: 3032:
        -: 3033:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3034:
        -: 3035:// template <class T, class... Args> struct is_constructible;
        -: 3036:
        -: 3037:namespace __is_construct
        -: 3038:{
        -: 3039:struct __nat {};
        -: 3040:}
        -: 3041:
        -: 3042:#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \
        -: 3043:    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))
        -: 3044:
        -: 3045:template <class _Tp, class... _Args>
        -: 3046:struct __libcpp_is_constructible;
        -: 3047:
        -: 3048:template <class _To, class _From>
        -: 3049:struct __is_invalid_base_to_derived_cast {
        -: 3050:  static_assert(is_reference<_To>::value, "Wrong specialization");
        -: 3051:  using _RawFrom = __uncvref_t<_From>;
        -: 3052:  using _RawTo = __uncvref_t<_To>;
        -: 3053:  static const bool value = __lazy_and<
        -: 3054:        __lazy_not<is_same<_RawFrom, _RawTo>>,
        -: 3055:        is_base_of<_RawFrom, _RawTo>,
        -: 3056:        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>
        -: 3057:  >::value;
        -: 3058:};
        -: 3059:
        -: 3060:template <class _To, class _From>
        -: 3061:struct __is_invalid_lvalue_to_rvalue_cast : false_type {
        -: 3062:  static_assert(is_reference<_To>::value, "Wrong specialization");
        -: 3063:};
        -: 3064:
        -: 3065:template <class _ToRef, class _FromRef>
        -: 3066:struct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {
        -: 3067:  using _RawFrom = __uncvref_t<_FromRef>;
        -: 3068:  using _RawTo = __uncvref_t<_ToRef>;
        -: 3069:  static const bool value = __lazy_and<
        -: 3070:      __lazy_not<is_function<_RawTo>>,
        -: 3071:      __lazy_or<
        -: 3072:        is_same<_RawFrom, _RawTo>,
        -: 3073:        is_base_of<_RawTo, _RawFrom>>
        -: 3074:    >::value;
        -: 3075:};
        -: 3076:
        -: 3077:struct __is_constructible_helper
        -: 3078:{
        -: 3079:    template <class _To>
        -: 3080:    static void __eat(_To);
        -: 3081:
        -: 3082:    // This overload is needed to work around a Clang bug that disallows
        -: 3083:    // static_cast<T&&>(e) for non-reference-compatible types.
        -: 3084:    // Example: static_cast<int&&>(declval<double>());
        -: 3085:    // NOTE: The static_cast implementation below is required to support
        -: 3086:    //  classes with explicit conversion operators.
        -: 3087:    template <class _To, class _From,
        -: 3088:              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>
        -: 3089:    static true_type __test_cast(int);
        -: 3090:
        -: 3091:    template <class _To, class _From,
        -: 3092:              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>
        -: 3093:    static integral_constant<bool,
        -: 3094:        !__is_invalid_base_to_derived_cast<_To, _From>::value &&
        -: 3095:        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value
        -: 3096:    > __test_cast(long);
        -: 3097:
        -: 3098:    template <class, class>
        -: 3099:    static false_type __test_cast(...);
        -: 3100:
        -: 3101:    template <class _Tp, class ..._Args,
        -: 3102:        class = decltype(_Tp(_VSTD::declval<_Args>()...))>
        -: 3103:    static true_type __test_nary(int);
        -: 3104:    template <class _Tp, class...>
        -: 3105:    static false_type __test_nary(...);
        -: 3106:
        -: 3107:    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>
        -: 3108:    static is_destructible<_Tp> __test_unary(int);
        -: 3109:    template <class, class>
        -: 3110:    static false_type __test_unary(...);
        -: 3111:};
        -: 3112:
        -: 3113:template <class _Tp, bool = is_void<_Tp>::value>
        -: 3114:struct __is_default_constructible
        -: 3115:    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))
        -: 3116:{};
        -: 3117:
        -: 3118:template <class _Tp>
        -: 3119:struct __is_default_constructible<_Tp, true> : false_type {};
        -: 3120:
        -: 3121:template <class _Tp>
        -: 3122:struct __is_default_constructible<_Tp[], false> : false_type {};
        -: 3123:
        -: 3124:template <class _Tp, size_t _Nx>
        -: 3125:struct __is_default_constructible<_Tp[_Nx], false>
        -: 3126:    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};
        -: 3127:
        -: 3128:template <class _Tp, class... _Args>
        -: 3129:struct __libcpp_is_constructible
        -: 3130:{
        -: 3131:  static_assert(sizeof...(_Args) > 1, "Wrong specialization");
        -: 3132:  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))
        -: 3133:      type;
        -: 3134:};
        -: 3135:
        -: 3136:template <class _Tp>
        -: 3137:struct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};
        -: 3138:
        -: 3139:template <class _Tp, class _A0>
        -: 3140:struct __libcpp_is_constructible<_Tp, _A0>
        -: 3141:    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))
        -: 3142:{};
        -: 3143:
        -: 3144:template <class _Tp, class _A0>
        -: 3145:struct __libcpp_is_constructible<_Tp&, _A0>
        -: 3146:    : public decltype(__is_constructible_helper::
        -: 3147:    __test_cast<_Tp&, _A0>(0))
        -: 3148:{};
        -: 3149:
        -: 3150:template <class _Tp, class _A0>
        -: 3151:struct __libcpp_is_constructible<_Tp&&, _A0>
        -: 3152:    : public decltype(__is_constructible_helper::
        -: 3153:    __test_cast<_Tp&&, _A0>(0))
        -: 3154:{};
        -: 3155:
        -: 3156:#endif
        -: 3157:
        -: 3158:#if __has_feature(is_constructible)
        -: 3159:template <class _Tp, class ..._Args>
        -: 3160:struct _LIBCPP_TEMPLATE_VIS is_constructible
        -: 3161:    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
        -: 3162:    {};
        -: 3163:#elif !defined(_LIBCPP_CXX03_LANG)
        -: 3164:template <class _Tp, class... _Args>
        -: 3165:struct _LIBCPP_TEMPLATE_VIS is_constructible
        -: 3166:    : public __libcpp_is_constructible<_Tp, _Args...>::type {};
        -: 3167:#else
        -: 3168:// template <class T> struct is_constructible0;
        -: 3169:
        -: 3170://      main is_constructible0 test
        -: 3171:
        -: 3172:template <class _Tp>
        -: 3173:decltype((_Tp(), true_type()))
        -: 3174:__is_constructible0_test(_Tp&);
        -: 3175:
        -: 3176:false_type
        -: 3177:__is_constructible0_test(__any);
        -: 3178:
        -: 3179:template <class _Tp, class _A0>
        -: 3180:decltype((_Tp(_VSTD::declval<_A0>()), true_type()))
        -: 3181:__is_constructible1_test(_Tp&, _A0&);
        -: 3182:
        -: 3183:template <class _A0>
        -: 3184:false_type
        -: 3185:__is_constructible1_test(__any, _A0&);
        -: 3186:
        -: 3187:template <class _Tp, class _A0, class _A1>
        -: 3188:decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
        -: 3189:__is_constructible2_test(_Tp&, _A0&, _A1&);
        -: 3190:
        -: 3191:template <class _A0, class _A1>
        -: 3192:false_type
        -: 3193:__is_constructible2_test(__any, _A0&, _A1&);
        -: 3194:
        -: 3195:template <class _Tp, class _A0, class _A1, class _A2>
        -: 3196:decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>(), _VSTD::declval<_A2>()), true_type()))
        -: 3197:__is_constructible3_test(_Tp&, _A0&, _A1&, _A2&);
        -: 3198:
        -: 3199:template <class _A0, class _A1, class _A2>
        -: 3200:false_type
        -: 3201:__is_constructible3_test(__any, _A0&, _A1&, _A2&);
        -: 3202:
        -: 3203:template <bool, class _Tp>
        -: 3204:struct __is_constructible0_imp // false, _Tp is not a scalar
        -: 3205:    : public common_type
        -: 3206:             <
        -: 3207:                 decltype(__is_constructible0_test(declval<_Tp&>()))
        -: 3208:             >::type
        -: 3209:    {};
        -: 3210:
        -: 3211:template <bool, class _Tp, class _A0>
        -: 3212:struct __is_constructible1_imp // false, _Tp is not a scalar
        -: 3213:    : public common_type
        -: 3214:             <
        -: 3215:                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
        -: 3216:             >::type
        -: 3217:    {};
        -: 3218:
        -: 3219:template <bool, class _Tp, class _A0, class _A1>
        -: 3220:struct __is_constructible2_imp // false, _Tp is not a scalar
        -: 3221:    : public common_type
        -: 3222:             <
        -: 3223:                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
        -: 3224:             >::type
        -: 3225:    {};
        -: 3226:
        -: 3227:template <bool, class _Tp, class _A0, class _A1, class _A2>
        -: 3228:struct __is_constructible3_imp // false, _Tp is not a scalar
        -: 3229:    : public common_type
        -: 3230:             <
        -: 3231:                 decltype(__is_constructible3_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>(), declval<_A2>()))
        -: 3232:             >::type
        -: 3233:    {};
        -: 3234:
        -: 3235://      handle scalars and reference types
        -: 3236:
        -: 3237://      Scalars are default constructible, references are not
        -: 3238:
        -: 3239:template <class _Tp>
        -: 3240:struct __is_constructible0_imp<true, _Tp>
        -: 3241:    : public is_scalar<_Tp>
        -: 3242:    {};
        -: 3243:
        -: 3244:template <class _Tp, class _A0>
        -: 3245:struct __is_constructible1_imp<true, _Tp, _A0>
        -: 3246:    : public is_convertible<_A0, _Tp>
        -: 3247:    {};
        -: 3248:
        -: 3249:template <class _Tp, class _A0, class _A1>
        -: 3250:struct __is_constructible2_imp<true, _Tp, _A0, _A1>
        -: 3251:    : public false_type
        -: 3252:    {};
        -: 3253:
        -: 3254:template <class _Tp, class _A0, class _A1, class _A2>
        -: 3255:struct __is_constructible3_imp<true, _Tp, _A0, _A1, _A2>
        -: 3256:    : public false_type
        -: 3257:    {};
        -: 3258:
        -: 3259://      Treat scalars and reference types separately
        -: 3260:
        -: 3261:template <bool, class _Tp>
        -: 3262:struct __is_constructible0_void_check
        -: 3263:    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 3264:                                _Tp>
        -: 3265:    {};
        -: 3266:
        -: 3267:template <bool, class _Tp, class _A0>
        -: 3268:struct __is_constructible1_void_check
        -: 3269:    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 3270:                                _Tp, _A0>
        -: 3271:    {};
        -: 3272:
        -: 3273:template <bool, class _Tp, class _A0, class _A1>
        -: 3274:struct __is_constructible2_void_check
        -: 3275:    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 3276:                                _Tp, _A0, _A1>
        -: 3277:    {};
        -: 3278:
        -: 3279:template <bool, class _Tp, class _A0, class _A1, class _A2>
        -: 3280:struct __is_constructible3_void_check
        -: 3281:    : public __is_constructible3_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 3282:                                _Tp, _A0, _A1, _A2>
        -: 3283:    {};
        -: 3284:
        -: 3285://      If any of T or Args is void, is_constructible should be false
        -: 3286:
        -: 3287:template <class _Tp>
        -: 3288:struct __is_constructible0_void_check<true, _Tp>
        -: 3289:    : public false_type
        -: 3290:    {};
        -: 3291:
        -: 3292:template <class _Tp, class _A0>
        -: 3293:struct __is_constructible1_void_check<true, _Tp, _A0>
        -: 3294:    : public false_type
        -: 3295:    {};
        -: 3296:
        -: 3297:template <class _Tp, class _A0, class _A1>
        -: 3298:struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
        -: 3299:    : public false_type
        -: 3300:    {};
        -: 3301:
        -: 3302:template <class _Tp, class _A0, class _A1, class _A2>
        -: 3303:struct __is_constructible3_void_check<true, _Tp, _A0, _A1, _A2>
        -: 3304:    : public false_type
        -: 3305:    {};
        -: 3306:
        -: 3307://      is_constructible entry point
        -: 3308:
        -: 3309:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 3310:                     class _A1 = __is_construct::__nat,
        -: 3311:                     class _A2 = __is_construct::__nat>
        -: 3312:struct _LIBCPP_TEMPLATE_VIS is_constructible
        -: 3313:    : public __is_constructible3_void_check<is_void<_Tp>::value
        -: 3314:                                        || is_abstract<_Tp>::value
        -: 3315:                                        || is_function<_Tp>::value
        -: 3316:                                        || is_void<_A0>::value
        -: 3317:                                        || is_void<_A1>::value
        -: 3318:                                        || is_void<_A2>::value,
        -: 3319:                                           _Tp, _A0, _A1, _A2>
        -: 3320:    {};
        -: 3321:
        -: 3322:template <class _Tp>
        -: 3323:struct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
        -: 3324:    : public __is_constructible0_void_check<is_void<_Tp>::value
        -: 3325:                                        || is_abstract<_Tp>::value
        -: 3326:                                        || is_function<_Tp>::value,
        -: 3327:                                           _Tp>
        -: 3328:    {};
        -: 3329:
        -: 3330:template <class _Tp, class _A0>
        -: 3331:struct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>
        -: 3332:    : public __is_constructible1_void_check<is_void<_Tp>::value
        -: 3333:                                        || is_abstract<_Tp>::value
        -: 3334:                                        || is_function<_Tp>::value
        -: 3335:                                        || is_void<_A0>::value,
        -: 3336:                                           _Tp, _A0>
        -: 3337:    {};
        -: 3338:
        -: 3339:template <class _Tp, class _A0, class _A1>
        -: 3340:struct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, _A1, __is_construct::__nat>
        -: 3341:    : public __is_constructible2_void_check<is_void<_Tp>::value
        -: 3342:                                        || is_abstract<_Tp>::value
        -: 3343:                                        || is_function<_Tp>::value
        -: 3344:                                        || is_void<_A0>::value
        -: 3345:                                        || is_void<_A1>::value,
        -: 3346:                                           _Tp, _A0, _A1>
        -: 3347:    {};
        -: 3348:
        -: 3349://      Array types are default constructible if their element type
        -: 3350://      is default constructible
        -: 3351:
        -: 3352:template <class _Ap, size_t _Np>
        -: 3353:struct __is_constructible0_imp<false, _Ap[_Np]>
        -: 3354:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 3355:    {};
        -: 3356:
        -: 3357:template <class _Ap, size_t _Np, class _A0>
        -: 3358:struct __is_constructible1_imp<false, _Ap[_Np], _A0>
        -: 3359:    : public false_type
        -: 3360:    {};
        -: 3361:
        -: 3362:template <class _Ap, size_t _Np, class _A0, class _A1>
        -: 3363:struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
        -: 3364:    : public false_type
        -: 3365:    {};
        -: 3366:
        -: 3367:template <class _Ap, size_t _Np, class _A0, class _A1, class _A2>
        -: 3368:struct __is_constructible3_imp<false, _Ap[_Np], _A0, _A1, _A2>
        -: 3369:    : public false_type
        -: 3370:    {};
        -: 3371:
        -: 3372://      Incomplete array types are not constructible
        -: 3373:
        -: 3374:template <class _Ap>
        -: 3375:struct __is_constructible0_imp<false, _Ap[]>
        -: 3376:    : public false_type
        -: 3377:    {};
        -: 3378:
        -: 3379:template <class _Ap, class _A0>
        -: 3380:struct __is_constructible1_imp<false, _Ap[], _A0>
        -: 3381:    : public false_type
        -: 3382:    {};
        -: 3383:
        -: 3384:template <class _Ap, class _A0, class _A1>
        -: 3385:struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
        -: 3386:    : public false_type
        -: 3387:    {};
        -: 3388:
        -: 3389:template <class _Ap, class _A0, class _A1, class _A2>
        -: 3390:struct __is_constructible3_imp<false, _Ap[], _A0, _A1, _A2>
        -: 3391:    : public false_type
        -: 3392:    {};
        -: 3393:
        -: 3394:#endif // __has_feature(is_constructible)
        -: 3395:
        -: 3396:
        -: 3397:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
        -: 3398:template <class _Tp, class ..._Args>
        -: 3399:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_constructible_v
        -: 3400:    = is_constructible<_Tp, _Args...>::value;
        -: 3401:#endif
        -: 3402:
        -: 3403:// is_default_constructible
        -: 3404:
        -: 3405:template <class _Tp>
        -: 3406:struct _LIBCPP_TEMPLATE_VIS is_default_constructible
        -: 3407:    : public is_constructible<_Tp>
        -: 3408:    {};
        -: 3409:
        -: 3410:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3411:template <class _Tp>
        -: 3412:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_default_constructible_v
        -: 3413:    = is_default_constructible<_Tp>::value;
        -: 3414:#endif
        -: 3415:
        -: 3416:// is_copy_constructible
        -: 3417:
        -: 3418:template <class _Tp>
        -: 3419:struct _LIBCPP_TEMPLATE_VIS is_copy_constructible
        -: 3420:    : public is_constructible<_Tp,
        -: 3421:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3422:
        -: 3423:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3424:template <class _Tp>
        -: 3425:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_constructible_v
        -: 3426:    = is_copy_constructible<_Tp>::value;
        -: 3427:#endif
        -: 3428:
        -: 3429:// is_move_constructible
        -: 3430:
        -: 3431:template <class _Tp>
        -: 3432:struct _LIBCPP_TEMPLATE_VIS is_move_constructible
        -: 3433:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3434:    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3435:#else
        -: 3436:    : public is_copy_constructible<_Tp>
        -: 3437:#endif
        -: 3438:    {};
        -: 3439:
        -: 3440:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3441:template <class _Tp>
        -: 3442:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_constructible_v
        -: 3443:    = is_move_constructible<_Tp>::value;
        -: 3444:#endif
        -: 3445:
        -: 3446:// is_trivially_constructible
        -: 3447:
        -: 3448:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 3449:
        -: 3450:#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
        -: 3451:
        -: 3452:template <class _Tp, class... _Args>
        -: 3453:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
        -: 3454:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
        -: 3455:{
        -: 3456:};
        -: 3457:
        -: 3458:#else  // !__has_feature(is_trivially_constructible)
        -: 3459:
        -: 3460:template <class _Tp, class... _Args>
        -: 3461:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
        -: 3462:    : false_type
        -: 3463:{
        -: 3464:};
        -: 3465:
        -: 3466:template <class _Tp>
        -: 3467:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>
        -: 3468:#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
        -: 3469:    : integral_constant<bool, __has_trivial_constructor(_Tp)>
        -: 3470:#else
        -: 3471:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3472:#endif
        -: 3473:{
        -: 3474:};
        -: 3475:
        -: 3476:template <class _Tp>
        -: 3477:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3478:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>
        -: 3479:#else
        -: 3480:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>
        -: 3481:#endif
        -: 3482:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3483:{
        -: 3484:};
        -: 3485:
        -: 3486:template <class _Tp>
        -: 3487:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>
        -: 3488:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3489:{
        -: 3490:};
        -: 3491:
        -: 3492:template <class _Tp>
        -: 3493:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>
        -: 3494:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3495:{
        -: 3496:};
        -: 3497:
        -: 3498:#endif  // !__has_feature(is_trivially_constructible)
        -: 3499:
        -: 3500:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 3501:
        -: 3502:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 3503:                     class _A1 = __is_construct::__nat>
        -: 3504:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
        -: 3505:    : false_type
        -: 3506:{
        -: 3507:};
        -: 3508:
        -: 3509:#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
        -: 3510:
        -: 3511:template <class _Tp>
        -: 3512:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 3513:                                                       __is_construct::__nat>
        -: 3514:    : integral_constant<bool, __is_trivially_constructible(_Tp)>
        -: 3515:{
        -: 3516:};
        -: 3517:
        -: 3518:template <class _Tp>
        -: 3519:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
        -: 3520:                                                       __is_construct::__nat>
        -: 3521:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
        -: 3522:{
        -: 3523:};
        -: 3524:
        -: 3525:template <class _Tp>
        -: 3526:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
        -: 3527:                                                       __is_construct::__nat>
        -: 3528:    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
        -: 3529:{
        -: 3530:};
        -: 3531:
        -: 3532:template <class _Tp>
        -: 3533:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
        -: 3534:                                                       __is_construct::__nat>
        -: 3535:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
        -: 3536:{
        -: 3537:};
        -: 3538:
        -: 3539:#else  // !__has_feature(is_trivially_constructible)
        -: 3540:
        -: 3541:template <class _Tp>
        -: 3542:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 3543:                                                       __is_construct::__nat>
        -: 3544:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3545:{
        -: 3546:};
        -: 3547:
        -: 3548:template <class _Tp>
        -: 3549:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
        -: 3550:                                                       __is_construct::__nat>
        -: 3551:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3552:{
        -: 3553:};
        -: 3554:
        -: 3555:template <class _Tp>
        -: 3556:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
        -: 3557:                                                       __is_construct::__nat>
        -: 3558:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3559:{
        -: 3560:};
        -: 3561:
        -: 3562:template <class _Tp>
        -: 3563:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
        -: 3564:                                                       __is_construct::__nat>
        -: 3565:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3566:{
        -: 3567:};
        -: 3568:
        -: 3569:#endif  // !__has_feature(is_trivially_constructible)
        -: 3570:
        -: 3571:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3572:
        -: 3573:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
        -: 3574:template <class _Tp, class... _Args>
        -: 3575:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_constructible_v
        -: 3576:    = is_trivially_constructible<_Tp, _Args...>::value;
        -: 3577:#endif
        -: 3578:
        -: 3579:// is_trivially_default_constructible
        -: 3580:
        -: 3581:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible
        -: 3582:    : public is_trivially_constructible<_Tp>
        -: 3583:    {};
        -: 3584:
        -: 3585:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3586:template <class _Tp>
        -: 3587:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v
        -: 3588:    = is_trivially_default_constructible<_Tp>::value;
        -: 3589:#endif
        -: 3590:
        -: 3591:// is_trivially_copy_constructible
        -: 3592:
        -: 3593:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible
        -: 3594:    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
        -: 3595:    {};
        -: 3596:
        -: 3597:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3598:template <class _Tp>
        -: 3599:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v
        -: 3600:    = is_trivially_copy_constructible<_Tp>::value;
        -: 3601:#endif
        -: 3602:
        -: 3603:// is_trivially_move_constructible
        -: 3604:
        -: 3605:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible
        -: 3606:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3607:    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3608:#else
        -: 3609:    : public is_trivially_copy_constructible<_Tp>
        -: 3610:#endif
        -: 3611:    {};
        -: 3612:
        -: 3613:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3614:template <class _Tp>
        -: 3615:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v
        -: 3616:    = is_trivially_move_constructible<_Tp>::value;
        -: 3617:#endif
        -: 3618:
        -: 3619:// is_trivially_assignable
        -: 3620:
        -: 3621:#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
        -: 3622:
        -: 3623:template <class _Tp, class _Arg>
        -: 3624:struct is_trivially_assignable
        -: 3625:    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
        -: 3626:{
        -: 3627:};
        -: 3628:
        -: 3629:#else  // !__has_feature(is_trivially_assignable)
        -: 3630:
        -: 3631:template <class _Tp, class _Arg>
        -: 3632:struct is_trivially_assignable
        -: 3633:    : public false_type {};
        -: 3634:
        -: 3635:template <class _Tp>
        -: 3636:struct is_trivially_assignable<_Tp&, _Tp>
        -: 3637:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3638:
        -: 3639:template <class _Tp>
        -: 3640:struct is_trivially_assignable<_Tp&, _Tp&>
        -: 3641:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3642:
        -: 3643:template <class _Tp>
        -: 3644:struct is_trivially_assignable<_Tp&, const _Tp&>
        -: 3645:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3646:
        -: 3647:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3648:
        -: 3649:template <class _Tp>
        -: 3650:struct is_trivially_assignable<_Tp&, _Tp&&>
        -: 3651:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3652:
        -: 3653:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3654:
        -: 3655:#endif  // !__has_feature(is_trivially_assignable)
        -: 3656:
        -: 3657:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3658:template <class _Tp, class _Arg>
        -: 3659:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_assignable_v
        -: 3660:    = is_trivially_assignable<_Tp, _Arg>::value;
        -: 3661:#endif
        -: 3662:
        -: 3663:// is_trivially_copy_assignable
        -: 3664:
        -: 3665:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable
        -: 3666:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3667:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3668:
        -: 3669:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3670:template <class _Tp>
        -: 3671:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v
        -: 3672:    = is_trivially_copy_assignable<_Tp>::value;
        -: 3673:#endif
        -: 3674:
        -: 3675:// is_trivially_move_assignable
        -: 3676:
        -: 3677:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable
        -: 3678:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3679:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3680:                                     typename add_rvalue_reference<_Tp>::type>
        -: 3681:#else
        -: 3682:                                     typename add_lvalue_reference<_Tp>::type>
        -: 3683:#endif
        -: 3684:    {};
        -: 3685:
        -: 3686:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3687:template <class _Tp>
        -: 3688:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v
        -: 3689:    = is_trivially_move_assignable<_Tp>::value;
        -: 3690:#endif
        -: 3691:
        -: 3692:// is_trivially_destructible
        -: 3693:
        -: 3694:#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
        -: 3695:
        -: 3696:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
        -: 3697:    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
        -: 3698:
        -: 3699:#else
        -: 3700:
        -: 3701:template <class _Tp> struct __libcpp_trivial_destructor
        -: 3702:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 3703:                                     is_reference<_Tp>::value> {};
        -: 3704:
        -: 3705:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
        -: 3706:    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 3707:
        -: 3708:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>
        -: 3709:    : public false_type {};
        -: 3710:
        -: 3711:#endif
        -: 3712:
        -: 3713:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3714:template <class _Tp>
        -: 3715:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_destructible_v
        -: 3716:    = is_trivially_destructible<_Tp>::value;
        -: 3717:#endif
        -: 3718:
        -: 3719:// is_nothrow_constructible
        -: 3720:
        -: 3721:#if 0
        -: 3722:template <class _Tp, class... _Args>
        -: 3723:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3724:    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>
        -: 3725:{
        -: 3726:};
        -: 3727:
        -: 3728:#else
        -: 3729:
        -: 3730:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 3731:
        -: 3732:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3733:
        -: 3734:template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
        -: 3735:
        -: 3736:template <class _Tp, class... _Args>
        -: 3737:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>
        -: 3738:    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
        -: 3739:{
        -: 3740:};
        -: 3741:
        -: 3742:template <class _Tp>
        -: 3743:void __implicit_conversion_to(_Tp) noexcept { }
        -: 3744:
        -: 3745:template <class _Tp, class _Arg>
        -: 3746:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>
        -: 3747:    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
        -: 3748:{
        -: 3749:};
        -: 3750:
        -: 3751:template <class _Tp, bool _IsReference, class... _Args>
        -: 3752:struct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>
        -: 3753:    : public false_type
        -: 3754:{
        -: 3755:};
        -: 3756:
        -: 3757:template <class _Tp, class... _Args>
        -: 3758:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3759:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
        -: 3760:{
        -: 3761:};
        -: 3762:
        -: 3763:template <class _Tp, size_t _Ns>
        -: 3764:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>
        -: 3765:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
        -: 3766:{
        -: 3767:};
        -: 3768:
        -: 3769:#else  // __has_feature(cxx_noexcept)
        -: 3770:
        -: 3771:template <class _Tp, class... _Args>
        -: 3772:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3773:    : false_type
        -: 3774:{
        -: 3775:};
        -: 3776:
        -: 3777:template <class _Tp>
        -: 3778:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>
        -: 3779:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 3780:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 3781:#else
        -: 3782:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3783:#endif
        -: 3784:{
        -: 3785:};
        -: 3786:
        -: 3787:template <class _Tp>
        -: 3788:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3789:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>
        -: 3790:#else
        -: 3791:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>
        -: 3792:#endif
        -: 3793:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3794:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3795:#else
        -: 3796:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3797:#endif
        -: 3798:{
        -: 3799:};
        -: 3800:
        -: 3801:template <class _Tp>
        -: 3802:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>
        -: 3803:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3804:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3805:#else
        -: 3806:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3807:#endif
        -: 3808:{
        -: 3809:};
        -: 3810:
        -: 3811:template <class _Tp>
        -: 3812:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>
        -: 3813:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3814:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3815:#else
        -: 3816:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3817:#endif
        -: 3818:{
        -: 3819:};
        -: 3820:
        -: 3821:#endif  // __has_feature(cxx_noexcept)
        -: 3822:
        -: 3823:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 3824:
        -: 3825:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 3826:                     class _A1 = __is_construct::__nat>
        -: 3827:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3828:    : false_type
        -: 3829:{
        -: 3830:};
        -: 3831:
        -: 3832:template <class _Tp>
        -: 3833:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,
        -: 3834:                                                       __is_construct::__nat>
        -: 3835:#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
        -: 3836:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 3837:#else
        -: 3838:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3839:#endif
        -: 3840:{
        -: 3841:};
        -: 3842:
        -: 3843:template <class _Tp>
        -: 3844:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,
        -: 3845:                                                       __is_construct::__nat>
        -: 3846:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3847:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3848:#else
        -: 3849:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3850:#endif
        -: 3851:{
        -: 3852:};
        -: 3853:
        -: 3854:template <class _Tp>
        -: 3855:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,
        -: 3856:                                                       __is_construct::__nat>
        -: 3857:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3858:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3859:#else
        -: 3860:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3861:#endif
        -: 3862:{
        -: 3863:};
        -: 3864:
        -: 3865:template <class _Tp>
        -: 3866:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,
        -: 3867:                                                       __is_construct::__nat>
        -: 3868:#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
        -: 3869:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 3870:#else
        -: 3871:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3872:#endif
        -: 3873:{
        -: 3874:};
        -: 3875:
        -: 3876:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3877:#endif  // __has_feature(is_nothrow_constructible)
        -: 3878:
        -: 3879:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
        -: 3880:template <class _Tp, class ..._Args>
        -: 3881:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v
        -: 3882:    = is_nothrow_constructible<_Tp, _Args...>::value;
        -: 3883:#endif
        -: 3884:
        -: 3885:// is_nothrow_default_constructible
        -: 3886:
        -: 3887:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
        -: 3888:    : public is_nothrow_constructible<_Tp>
        -: 3889:    {};
        -: 3890:
        -: 3891:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3892:template <class _Tp>
        -: 3893:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v
        -: 3894:    = is_nothrow_default_constructible<_Tp>::value;
        -: 3895:#endif
        -: 3896:
        -: 3897:// is_nothrow_copy_constructible
        -: 3898:
        -: 3899:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible
        -: 3900:    : public is_nothrow_constructible<_Tp,
        -: 3901:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3902:
        -: 3903:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3904:template <class _Tp>
        -: 3905:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v
        -: 3906:    = is_nothrow_copy_constructible<_Tp>::value;
        -: 3907:#endif
        -: 3908:
        -: 3909:// is_nothrow_move_constructible
        -: 3910:
        -: 3911:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible
        -: 3912:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3913:    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3914:#else
        -: 3915:    : public is_nothrow_copy_constructible<_Tp>
        -: 3916:#endif
        -: 3917:    {};
        -: 3918:
        -: 3919:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3920:template <class _Tp>
        -: 3921:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v
        -: 3922:    = is_nothrow_move_constructible<_Tp>::value;
        -: 3923:#endif
        -: 3924:
        -: 3925:// is_nothrow_assignable
        -: 3926:
        -: 3927:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 3928:
        -: 3929:template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
        -: 3930:
        -: 3931:template <class _Tp, class _Arg>
        -: 3932:struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
        -: 3933:    : public false_type
        -: 3934:{
        -: 3935:};
        -: 3936:
        -: 3937:template <class _Tp, class _Arg>
        -: 3938:struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
        -: 3939:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
        -: 3940:{
        -: 3941:};
        -: 3942:
        -: 3943:template <class _Tp, class _Arg>
        -: 3944:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
        -: 3945:    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
        -: 3946:{
        -: 3947:};
        -: 3948:
        -: 3949:#else  // __has_feature(cxx_noexcept)
        -: 3950:
        -: 3951:template <class _Tp, class _Arg>
        -: 3952:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
        -: 3953:    : public false_type {};
        -: 3954:
        -: 3955:template <class _Tp>
        -: 3956:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>
        -: 3957:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3958:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3959:#else
        -: 3960:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3961:#endif
        -: 3962:
        -: 3963:template <class _Tp>
        -: 3964:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>
        -: 3965:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3966:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3967:#else
        -: 3968:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3969:#endif
        -: 3970:
        -: 3971:template <class _Tp>
        -: 3972:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>
        -: 3973:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3974:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3975:#else
        -: 3976:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3977:#endif
        -: 3978:
        -: 3979:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3980:
        -: 3981:template <class _Tp>
        -: 3982:struct is_nothrow_assignable<_Tp&, _Tp&&>
        -: 3983:#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
        -: 3984:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 3985:#else
        -: 3986:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3987:#endif
        -: 3988:
        -: 3989:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 3990:
        -: 3991:#endif  // __has_feature(cxx_noexcept)
        -: 3992:
        -: 3993:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3994:template <class _Tp, class _Arg>
        -: 3995:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v
        -: 3996:    = is_nothrow_assignable<_Tp, _Arg>::value;
        -: 3997:#endif
        -: 3998:
        -: 3999:// is_nothrow_copy_assignable
        -: 4000:
        -: 4001:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
        -: 4002:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 4003:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 4004:
        -: 4005:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4006:template <class _Tp>
        -: 4007:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v
        -: 4008:    = is_nothrow_copy_assignable<_Tp>::value;
        -: 4009:#endif
        -: 4010:
        -: 4011:// is_nothrow_move_assignable
        -: 4012:
        -: 4013:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
        -: 4014:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 4015:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 4016:                                     typename add_rvalue_reference<_Tp>::type>
        -: 4017:#else
        -: 4018:                                     typename add_lvalue_reference<_Tp>::type>
        -: 4019:#endif
        -: 4020:    {};
        -: 4021:
        -: 4022:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4023:template <class _Tp>
        -: 4024:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v
        -: 4025:    = is_nothrow_move_assignable<_Tp>::value;
        -: 4026:#endif
        -: 4027:
        -: 4028:// is_nothrow_destructible
        -: 4029:
        -: 4030:#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
        -: 4031:
        -: 4032:template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
        -: 4033:
        -: 4034:template <class _Tp>
        -: 4035:struct __libcpp_is_nothrow_destructible<false, _Tp>
        -: 4036:    : public false_type
        -: 4037:{
        -: 4038:};
        -: 4039:
        -: 4040:template <class _Tp>
        -: 4041:struct __libcpp_is_nothrow_destructible<true, _Tp>
        -: 4042:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
        -: 4043:{
        -: 4044:};
        -: 4045:
        -: 4046:template <class _Tp>
        -: 4047:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
        -: 4048:    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
        -: 4049:{
        -: 4050:};
        -: 4051:
        -: 4052:template <class _Tp, size_t _Ns>
        -: 4053:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>
        -: 4054:    : public is_nothrow_destructible<_Tp>
        -: 4055:{
        -: 4056:};
        -: 4057:
        -: 4058:template <class _Tp>
        -: 4059:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>
        -: 4060:    : public true_type
        -: 4061:{
        -: 4062:};
        -: 4063:
        -: 4064:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 4065:
        -: 4066:template <class _Tp>
        -: 4067:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>
        -: 4068:    : public true_type
        -: 4069:{
        -: 4070:};
        -: 4071:
        -: 4072:#endif
        -: 4073:
        -: 4074:#else
        -: 4075:
        -: 4076:template <class _Tp> struct __libcpp_nothrow_destructor
        -: 4077:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 4078:                                     is_reference<_Tp>::value> {};
        -: 4079:
        -: 4080:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
        -: 4081:    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 4082:
        -: 4083:template <class _Tp>
        -: 4084:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>
        -: 4085:    : public false_type {};
        -: 4086:
        -: 4087:#endif
        -: 4088:
        -: 4089:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4090:template <class _Tp>
        -: 4091:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v
        -: 4092:    = is_nothrow_destructible<_Tp>::value;
        -: 4093:#endif
        -: 4094:
        -: 4095:// is_pod
        -: 4096:
        -: 4097:#if __has_feature(is_pod) || (_GNUC_VER >= 403)
        -: 4098:
        -: 4099:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
        -: 4100:    : public integral_constant<bool, __is_pod(_Tp)> {};
        -: 4101:
        -: 4102:#else
        -: 4103:
        -: 4104:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
        -: 4105:    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
        -: 4106:                                     is_trivially_copy_constructible<_Tp>::value      &&
        -: 4107:                                     is_trivially_copy_assignable<_Tp>::value    &&
        -: 4108:                                     is_trivially_destructible<_Tp>::value> {};
        -: 4109:
        -: 4110:#endif
        -: 4111:
        -: 4112:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4113:template <class _Tp>
        -: 4114:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pod_v
        -: 4115:    = is_pod<_Tp>::value;
        -: 4116:#endif
        -: 4117:
        -: 4118:// is_literal_type;
        -: 4119:
        -: 4120:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type
        -: 4121:#ifdef _LIBCPP_IS_LITERAL
        -: 4122:    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>
        -: 4123:#else
        -: 4124:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
        -: 4125:                              is_reference<typename remove_all_extents<_Tp>::type>::value>
        -: 4126:#endif
        -: 4127:    {};
        -: 4128:
        -: 4129:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4130:template <class _Tp>
        -: 4131:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_literal_type_v
        -: 4132:    = is_literal_type<_Tp>::value;
        -: 4133:#endif
        -: 4134:
        -: 4135:// is_standard_layout;
        -: 4136:
        -: 4137:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout
        -: 4138:#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
        -: 4139:    : public integral_constant<bool, __is_standard_layout(_Tp)>
        -: 4140:#else
        -: 4141:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 4142:#endif
        -: 4143:    {};
        -: 4144:
        -: 4145:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4146:template <class _Tp>
        -: 4147:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_standard_layout_v
        -: 4148:    = is_standard_layout<_Tp>::value;
        -: 4149:#endif
        -: 4150:
        -: 4151:// is_trivially_copyable;
        -: 4152:
        -: 4153:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable
        -: 4154:#if __has_feature(is_trivially_copyable)
        -: 4155:    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
        -: 4156:#elif _GNUC_VER >= 501
        -: 4157:    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>
        -: 4158:#else
        -: 4159:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 4160:#endif
        -: 4161:    {};
        -: 4162:
        -: 4163:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4164:template <class _Tp>
        -: 4165:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copyable_v
        -: 4166:    = is_trivially_copyable<_Tp>::value;
        -: 4167:#endif
        -: 4168:
        -: 4169:// is_trivial;
        -: 4170:
        -: 4171:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial
        -: 4172:#if __has_feature(is_trivial) || _GNUC_VER >= 407
        -: 4173:    : public integral_constant<bool, __is_trivial(_Tp)>
        -: 4174:#else
        -: 4175:    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
        -: 4176:                                 is_trivially_default_constructible<_Tp>::value>
        -: 4177:#endif
        -: 4178:    {};
        -: 4179:
        -: 4180:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 4181:template <class _Tp>
        -: 4182:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivial_v
        -: 4183:    = is_trivial<_Tp>::value;
        -: 4184:#endif
        -: 4185:
        -: 4186:template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
        -: 4187:template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
        -: 4188:template <class _Tp> struct __is_reference_wrapper
        -: 4189:    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
        -: 4190:
        -: 4191:#ifndef _LIBCPP_CXX03_LANG
        -: 4192:
        -: 4193:template <class _Fp, class _A0,
        -: 4194:         class _DecayFp = typename decay<_Fp>::type,
        -: 4195:         class _DecayA0 = typename decay<_A0>::type,
        -: 4196:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 4197:using __enable_if_bullet1 = typename enable_if
        -: 4198:    <
        -: 4199:        is_member_function_pointer<_DecayFp>::value
        -: 4200:        && is_base_of<_ClassT, _DecayA0>::value
        -: 4201:    >::type;
        -: 4202:
        -: 4203:template <class _Fp, class _A0,
        -: 4204:         class _DecayFp = typename decay<_Fp>::type,
        -: 4205:         class _DecayA0 = typename decay<_A0>::type>
        -: 4206:using __enable_if_bullet2 = typename enable_if
        -: 4207:    <
        -: 4208:        is_member_function_pointer<_DecayFp>::value
        -: 4209:        && __is_reference_wrapper<_DecayA0>::value
        -: 4210:    >::type;
        -: 4211:
        -: 4212:template <class _Fp, class _A0,
        -: 4213:         class _DecayFp = typename decay<_Fp>::type,
        -: 4214:         class _DecayA0 = typename decay<_A0>::type,
        -: 4215:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 4216:using __enable_if_bullet3 = typename enable_if
        -: 4217:    <
        -: 4218:        is_member_function_pointer<_DecayFp>::value
        -: 4219:        && !is_base_of<_ClassT, _DecayA0>::value
        -: 4220:        && !__is_reference_wrapper<_DecayA0>::value
        -: 4221:    >::type;
        -: 4222:
        -: 4223:template <class _Fp, class _A0,
        -: 4224:         class _DecayFp = typename decay<_Fp>::type,
        -: 4225:         class _DecayA0 = typename decay<_A0>::type,
        -: 4226:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 4227:using __enable_if_bullet4 = typename enable_if
        -: 4228:    <
        -: 4229:        is_member_object_pointer<_DecayFp>::value
        -: 4230:        && is_base_of<_ClassT, _DecayA0>::value
        -: 4231:    >::type;
        -: 4232:
        -: 4233:template <class _Fp, class _A0,
        -: 4234:         class _DecayFp = typename decay<_Fp>::type,
        -: 4235:         class _DecayA0 = typename decay<_A0>::type>
        -: 4236:using __enable_if_bullet5 = typename enable_if
        -: 4237:    <
        -: 4238:        is_member_object_pointer<_DecayFp>::value
        -: 4239:        && __is_reference_wrapper<_DecayA0>::value
        -: 4240:    >::type;
        -: 4241:
        -: 4242:template <class _Fp, class _A0,
        -: 4243:         class _DecayFp = typename decay<_Fp>::type,
        -: 4244:         class _DecayA0 = typename decay<_A0>::type,
        -: 4245:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 4246:using __enable_if_bullet6 = typename enable_if
        -: 4247:    <
        -: 4248:        is_member_object_pointer<_DecayFp>::value
        -: 4249:        && !is_base_of<_ClassT, _DecayA0>::value
        -: 4250:        && !__is_reference_wrapper<_DecayA0>::value
        -: 4251:    >::type;
        -: 4252:
        -: 4253:// __invoke forward declarations
        -: 4254:
        -: 4255:// fall back - none of the bullets
        -: 4256:
        -: 4257:#define _LIBCPP_INVOKE_RETURN(...) \
        -: 4258:    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
        -: 4259:    { return __VA_ARGS__; }
        -: 4260:
        -: 4261:template <class ..._Args>
        -: 4262:auto __invoke(__any, _Args&& ...__args) -> __nat;
        -: 4263:
        -: 4264:template <class ..._Args>
        -: 4265:auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;
        -: 4266:
        -: 4267:// bullets 1, 2 and 3
        -: 4268:
        -: 4269:template <class _Fp, class _A0, class ..._Args,
        -: 4270:          class = __enable_if_bullet1<_Fp, _A0>>
        -: 4271:inline _LIBCPP_INLINE_VISIBILITY
        -: 4272:auto
        -: 4273:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4274:_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4275:
        -: 4276:template <class _Fp, class _A0, class ..._Args,
        -: 4277:          class = __enable_if_bullet1<_Fp, _A0>>
        -: 4278:inline _LIBCPP_INLINE_VISIBILITY
        -: 4279:_LIBCPP_CONSTEXPR auto
        -: 4280:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4281:_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4282:
        -: 4283:template <class _Fp, class _A0, class ..._Args,
        -: 4284:          class = __enable_if_bullet2<_Fp, _A0>>
        -: 4285:inline _LIBCPP_INLINE_VISIBILITY
        -: 4286:auto
        -: 4287:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4288:_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4289:
        -: 4290:template <class _Fp, class _A0, class ..._Args,
        -: 4291:          class = __enable_if_bullet2<_Fp, _A0>>
        -: 4292:inline _LIBCPP_INLINE_VISIBILITY
        -: 4293:_LIBCPP_CONSTEXPR auto
        -: 4294:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4295:_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4296:
        -: 4297:template <class _Fp, class _A0, class ..._Args,
        -: 4298:          class = __enable_if_bullet3<_Fp, _A0>>
        -: 4299:inline _LIBCPP_INLINE_VISIBILITY
        -: 4300:auto
        -: 4301:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4302:_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4303:
        -: 4304:template <class _Fp, class _A0, class ..._Args,
        -: 4305:          class = __enable_if_bullet3<_Fp, _A0>>
        -: 4306:inline _LIBCPP_INLINE_VISIBILITY
        -: 4307:_LIBCPP_CONSTEXPR auto
        -: 4308:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 4309:_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 4310:
        -: 4311:// bullets 4, 5 and 6
        -: 4312:
        -: 4313:template <class _Fp, class _A0,
        -: 4314:          class = __enable_if_bullet4<_Fp, _A0>>
        -: 4315:inline _LIBCPP_INLINE_VISIBILITY
        -: 4316:auto
        -: 4317:__invoke(_Fp&& __f, _A0&& __a0)
        -: 4318:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
        -: 4319:
        -: 4320:template <class _Fp, class _A0,
        -: 4321:          class = __enable_if_bullet4<_Fp, _A0>>
        -: 4322:inline _LIBCPP_INLINE_VISIBILITY
        -: 4323:_LIBCPP_CONSTEXPR auto
        -: 4324:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 4325:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
        -: 4326:
        -: 4327:template <class _Fp, class _A0,
        -: 4328:          class = __enable_if_bullet5<_Fp, _A0>>
        -: 4329:inline _LIBCPP_INLINE_VISIBILITY
        -: 4330:auto
        -: 4331:__invoke(_Fp&& __f, _A0&& __a0)
        -: 4332:_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
        -: 4333:
        -: 4334:template <class _Fp, class _A0,
        -: 4335:          class = __enable_if_bullet5<_Fp, _A0>>
        -: 4336:inline _LIBCPP_INLINE_VISIBILITY
        -: 4337:_LIBCPP_CONSTEXPR auto
        -: 4338:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 4339:_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
        -: 4340:
        -: 4341:template <class _Fp, class _A0,
        -: 4342:          class = __enable_if_bullet6<_Fp, _A0>>
        -: 4343:inline _LIBCPP_INLINE_VISIBILITY
        -: 4344:auto
        -: 4345:__invoke(_Fp&& __f, _A0&& __a0)
        -: 4346:_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
        -: 4347:
        -: 4348:template <class _Fp, class _A0,
        -: 4349:          class = __enable_if_bullet6<_Fp, _A0>>
        -: 4350:inline _LIBCPP_INLINE_VISIBILITY
        -: 4351:_LIBCPP_CONSTEXPR auto
        -: 4352:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 4353:_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
        -: 4354:
        -: 4355:// bullet 7
        -: 4356:
        -: 4357:template <class _Fp, class ..._Args>
        -: 4358:inline _LIBCPP_INLINE_VISIBILITY
        -: 4359:auto
        -: 4360:__invoke(_Fp&& __f, _Args&& ...__args)
        -: 4361:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -: 4362:
        -: 4363:template <class _Fp, class ..._Args>
        -: 4364:inline _LIBCPP_INLINE_VISIBILITY
        -: 4365:_LIBCPP_CONSTEXPR auto
        -: 4366:__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
        -: 4367:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -: 4368:
        -: 4369:#undef _LIBCPP_INVOKE_RETURN
        -: 4370:
        -: 4371:// __invokable
        -: 4372:
        -: 4373:template <class _Ret, class _Fp, class ..._Args>
        -: 4374:struct __invokable_r
        -: 4375:{
        -: 4376:    // FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,
        -: 4377:    // or incomplete array types as required by the standard.
        -: 4378:    using _Result = decltype(
        -: 4379:        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
        -: 4380:
        -: 4381:    using type =
        -: 4382:        typename conditional<
        -: 4383:            !is_same<_Result, __nat>::value,
        -: 4384:            typename conditional<
        -: 4385:                is_void<_Ret>::value,
        -: 4386:                true_type,
        -: 4387:                is_convertible<_Result, _Ret>
        -: 4388:            >::type,
        -: 4389:            false_type
        -: 4390:        >::type;
        -: 4391:    static const bool value = type::value;
        -: 4392:};
        -: 4393:
        -: 4394:template <class _Fp, class ..._Args>
        -: 4395:using __invokable = __invokable_r<void, _Fp, _Args...>;
        -: 4396:
        -: 4397:template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
        -: 4398:struct __nothrow_invokable_r_imp {
        -: 4399:  static const bool value = false;
        -: 4400:};
        -: 4401:
        -: 4402:template <class _Ret, class _Fp, class ..._Args>
        -: 4403:struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
        -: 4404:{
        -: 4405:    typedef __nothrow_invokable_r_imp _ThisT;
        -: 4406:
        -: 4407:    template <class _Tp>
        -: 4408:    static void __test_noexcept(_Tp) noexcept;
        -: 4409:
        -: 4410:    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        -: 4411:        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));
        -: 4412:};
        -: 4413:
        -: 4414:template <class _Ret, class _Fp, class ..._Args>
        -: 4415:struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
        -: 4416:{
        -: 4417:    static const bool value = noexcept(
        -: 4418:        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
        -: 4419:};
        -: 4420:
        -: 4421:template <class _Ret, class _Fp, class ..._Args>
        -: 4422:using __nothrow_invokable_r =
        -: 4423:    __nothrow_invokable_r_imp<
        -: 4424:            __invokable_r<_Ret, _Fp, _Args...>::value,
        -: 4425:            is_void<_Ret>::value,
        -: 4426:            _Ret, _Fp, _Args...
        -: 4427:    >;
        -: 4428:
        -: 4429:template <class _Fp, class ..._Args>
        -: 4430:using __nothrow_invokable =
        -: 4431:    __nothrow_invokable_r_imp<
        -: 4432:            __invokable<_Fp, _Args...>::value,
        -: 4433:            true, void, _Fp, _Args...
        -: 4434:    >;
        -: 4435:
        -: 4436:template <class _Fp, class ..._Args>
        -: 4437:struct __invoke_of
        -: 4438:    : public enable_if<
        -: 4439:        __invokable<_Fp, _Args...>::value,
        -: 4440:        typename __invokable_r<void, _Fp, _Args...>::_Result>
        -: 4441:{
        -: 4442:};
        -: 4443:
        -: 4444:// result_of
        -: 4445:
        -: 4446:template <class _Fp, class ..._Args>
        -: 4447:class _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>
        -: 4448:    : public __invoke_of<_Fp, _Args...>
        -: 4449:{
        -: 4450:};
        -: 4451:
        -: 4452:#if _LIBCPP_STD_VER > 11
        -: 4453:template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
        -: 4454:#endif
        -: 4455:
        -: 4456:#if _LIBCPP_STD_VER > 14
        -: 4457:
        -: 4458:// invoke_result
        -: 4459:
        -: 4460:template <class _Fn, class... _Args>
        -: 4461:struct _LIBCPP_TEMPLATE_VIS invoke_result
        -: 4462:    : __invoke_of<_Fn, _Args...>
        -: 4463:{
        -: 4464:};
        -: 4465:
        -: 4466:template <class _Fn, class... _Args>
        -: 4467:using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
        -: 4468:
        -: 4469:// is_invocable
        -: 4470:
        -: 4471:template <class _Fn, class ..._Args>
        -: 4472:struct _LIBCPP_TEMPLATE_VIS is_invocable
        -: 4473:    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};
        -: 4474:
        -: 4475:template <class _Ret, class _Fn, class ..._Args>
        -: 4476:struct _LIBCPP_TEMPLATE_VIS is_invocable_r
        -: 4477:    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
        -: 4478:
        -: 4479:template <class _Fn, class ..._Args>
        -: 4480:_LIBCPP_INLINE_VAR constexpr bool is_invocable_v
        -: 4481:    = is_invocable<_Fn, _Args...>::value;
        -: 4482:
        -: 4483:template <class _Ret, class _Fn, class ..._Args>
        -: 4484:_LIBCPP_INLINE_VAR constexpr bool is_invocable_r_v
        -: 4485:    = is_invocable_r<_Ret, _Fn, _Args...>::value;
        -: 4486:
        -: 4487:// is_nothrow_invocable
        -: 4488:
        -: 4489:template <class _Fn, class ..._Args>
        -: 4490:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable
        -: 4491:    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};
        -: 4492:
        -: 4493:template <class _Ret, class _Fn, class ..._Args>
        -: 4494:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r
        -: 4495:    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};
        -: 4496:
        -: 4497:template <class _Fn, class ..._Args>
        -: 4498:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_v
        -: 4499:    = is_nothrow_invocable<_Fn, _Args...>::value;
        -: 4500:
        -: 4501:template <class _Ret, class _Fn, class ..._Args>
        -: 4502:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_r_v
        -: 4503:    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
        -: 4504:
        -: 4505:#endif // _LIBCPP_STD_VER > 14
        -: 4506:
        -: 4507:#endif  // !defined(_LIBCPP_CXX03_LANG)
        -: 4508:
        -: 4509:template <class _Tp> struct __is_swappable;
        -: 4510:template <class _Tp> struct __is_nothrow_swappable;
        -: 4511:
        -: 4512:template <class _Tp>
        -: 4513:inline _LIBCPP_INLINE_VISIBILITY
        -: 4514:#ifndef _LIBCPP_CXX03_LANG
        -: 4515:typename enable_if
        -: 4516:<
        -: 4517:    is_move_constructible<_Tp>::value &&
        -: 4518:    is_move_assignable<_Tp>::value
        -: 4519:>::type
        -: 4520:#else
        -: 4521:void
        -: 4522:#endif
        -: 4523:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -: 4524:                                    is_nothrow_move_assignable<_Tp>::value)
        -: 4525:{
        -: 4526:    _Tp __t(_VSTD::move(__x));
        -: 4527:    __x = _VSTD::move(__y);
        -: 4528:    __y = _VSTD::move(__t);
        -: 4529:}
        -: 4530:
        -: 4531:template<class _Tp, size_t _Np>
        -: 4532:inline _LIBCPP_INLINE_VISIBILITY
        -: 4533:typename enable_if<
        -: 4534:    __is_swappable<_Tp>::value
        -: 4535:>::type
        -: 4536:swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);
        -: 4537:
        -: 4538:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 4539:inline _LIBCPP_INLINE_VISIBILITY
        -: 4540:void
        -: 4541:iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        -: 4542:    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
        -: 4543:               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
        -: 4544:                                          *_VSTD::declval<_ForwardIterator2>())))
        -: 4545:{
        -: 4546:    swap(*__a, *__b);
        -: 4547:}
        -: 4548:
        -: 4549:// __swappable
        -: 4550:
        -: 4551:namespace __detail
        -: 4552:{
        -: 4553:// ALL generic swap overloads MUST already have a declaration available at this point.
        -: 4554:
        -: 4555:template <class _Tp, class _Up = _Tp,
        -: 4556:          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
        -: 4557:struct __swappable_with
        -: 4558:{
        -: 4559:    template <class _LHS, class _RHS>
        -: 4560:    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))
        -: 4561:    __test_swap(int);
        -: 4562:    template <class, class>
        -: 4563:    static __nat __test_swap(long);
        -: 4564:
        -: 4565:    // Extra parens are needed for the C++03 definition of decltype.
        -: 4566:    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
        -: 4567:    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
        -: 4568:
        -: 4569:    static const bool value = !is_same<__swap1, __nat>::value
        -: 4570:                           && !is_same<__swap2, __nat>::value;
        -: 4571:};
        -: 4572:
        -: 4573:template <class _Tp, class _Up>
        -: 4574:struct __swappable_with<_Tp, _Up,  false> : false_type {};
        -: 4575:
        -: 4576:template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
        -: 4577:struct __nothrow_swappable_with {
        -: 4578:  static const bool value =
        -: 4579:#ifndef _LIBCPP_HAS_NO_NOEXCEPT
        -: 4580:      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))
        -: 4581:  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));
        -: 4582:#else
        -: 4583:      false;
        -: 4584:#endif
        -: 4585:};
        -: 4586:
        -: 4587:template <class _Tp, class _Up>
        -: 4588:struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
        -: 4589:
        -: 4590:}  // __detail
        -: 4591:
        -: 4592:template <class _Tp>
        -: 4593:struct __is_swappable
        -: 4594:    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
        -: 4595:{
        -: 4596:};
        -: 4597:
        -: 4598:template <class _Tp>
        -: 4599:struct __is_nothrow_swappable
        -: 4600:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
        -: 4601:{
        -: 4602:};
        -: 4603:
        -: 4604:#if _LIBCPP_STD_VER > 14
        -: 4605:
        -: 4606:template <class _Tp, class _Up>
        -: 4607:struct _LIBCPP_TEMPLATE_VIS is_swappable_with
        -: 4608:    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
        -: 4609:{
        -: 4610:};
        -: 4611:
        -: 4612:template <class _Tp>
        -: 4613:struct _LIBCPP_TEMPLATE_VIS is_swappable
        -: 4614:    : public conditional<
        -: 4615:        __is_referenceable<_Tp>::value,
        -: 4616:        is_swappable_with<
        -: 4617:            typename add_lvalue_reference<_Tp>::type,
        -: 4618:            typename add_lvalue_reference<_Tp>::type>,
        -: 4619:        false_type
        -: 4620:    >::type
        -: 4621:{
        -: 4622:};
        -: 4623:
        -: 4624:template <class _Tp, class _Up>
        -: 4625:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with
        -: 4626:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
        -: 4627:{
        -: 4628:};
        -: 4629:
        -: 4630:template <class _Tp>
        -: 4631:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable
        -: 4632:    : public conditional<
        -: 4633:        __is_referenceable<_Tp>::value,
        -: 4634:        is_nothrow_swappable_with<
        -: 4635:            typename add_lvalue_reference<_Tp>::type,
        -: 4636:            typename add_lvalue_reference<_Tp>::type>,
        -: 4637:        false_type
        -: 4638:    >::type
        -: 4639:{
        -: 4640:};
        -: 4641:
        -: 4642:template <class _Tp, class _Up>
        -: 4643:_LIBCPP_INLINE_VAR constexpr bool is_swappable_with_v
        -: 4644:    = is_swappable_with<_Tp, _Up>::value;
        -: 4645:
        -: 4646:template <class _Tp>
        -: 4647:_LIBCPP_INLINE_VAR constexpr bool is_swappable_v
        -: 4648:    = is_swappable<_Tp>::value;
        -: 4649:
        -: 4650:template <class _Tp, class _Up>
        -: 4651:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_with_v
        -: 4652:    = is_nothrow_swappable_with<_Tp, _Up>::value;
        -: 4653:
        -: 4654:template <class _Tp>
        -: 4655:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_v
        -: 4656:    = is_nothrow_swappable<_Tp>::value;
        -: 4657:
        -: 4658:#endif // _LIBCPP_STD_VER > 14
        -: 4659:
        -: 4660:#ifdef _LIBCPP_UNDERLYING_TYPE
        -: 4661:
        -: 4662:template <class _Tp>
        -: 4663:struct underlying_type
        -: 4664:{
        -: 4665:    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;
        -: 4666:};
        -: 4667:
        -: 4668:#if _LIBCPP_STD_VER > 11
        -: 4669:template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
        -: 4670:#endif
        -: 4671:
        -: 4672:#else  // _LIBCPP_UNDERLYING_TYPE
        -: 4673:
        -: 4674:template <class _Tp, bool _Support = false>
        -: 4675:struct underlying_type
        -: 4676:{
        -: 4677:    static_assert(_Support, "The underyling_type trait requires compiler "
        -: 4678:                            "support. Either no such support exists or "
        -: 4679:                            "libc++ does not know how to use it.");
        -: 4680:};
        -: 4681:
        -: 4682:#endif // _LIBCPP_UNDERLYING_TYPE
        -: 4683:
        -: 4684:
        -: 4685:template <class _Tp, bool = is_enum<_Tp>::value>
        -: 4686:struct __sfinae_underlying_type
        -: 4687:{
        -: 4688:    typedef typename underlying_type<_Tp>::type type;
        -: 4689:    typedef decltype(((type)1) + 0) __promoted_type;
        -: 4690:};
        -: 4691:
        -: 4692:template <class _Tp>
        -: 4693:struct __sfinae_underlying_type<_Tp, false> {};
        -: 4694:
        -: 4695:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4696:int __convert_to_integral(int __val) { return __val; }
        -: 4697:
        -: 4698:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4699:unsigned __convert_to_integral(unsigned __val) { return __val; }
        -: 4700:
        -: 4701:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4702:long __convert_to_integral(long __val) { return __val; }
        -: 4703:
        -: 4704:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4705:unsigned long __convert_to_integral(unsigned long __val) { return __val; }
        -: 4706:
        -: 4707:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4708:long long __convert_to_integral(long long __val) { return __val; }
        -: 4709:
        -: 4710:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4711:unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
        -: 4712:
        -: 4713:template<typename _Fp>
        -: 4714:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4715:typename enable_if<is_floating_point<_Fp>::value, long long>::type
        -: 4716: __convert_to_integral(_Fp __val) { return __val; }
        -: 4717:
        -: 4718:#ifndef _LIBCPP_HAS_NO_INT128
        -: 4719:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4720:__int128_t __convert_to_integral(__int128_t __val) { return __val; }
        -: 4721:
        -: 4722:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4723:__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
        -: 4724:#endif
        -: 4725:
        -: 4726:template <class _Tp>
        -: 4727:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4728:typename __sfinae_underlying_type<_Tp>::__promoted_type
        -: 4729:__convert_to_integral(_Tp __val) { return __val; }
        -: 4730:
        -: 4731:#ifndef _LIBCPP_CXX03_LANG
        -: 4732:
        -: 4733:template <class _Tp>
        -: 4734:struct __has_operator_addressof_member_imp
        -: 4735:{
        -: 4736:    template <class _Up>
        -: 4737:        static auto __test(int)
        -: 4738:            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;
        -: 4739:    template <class>
        -: 4740:        static auto __test(long) -> false_type;
        -: 4741:
        -: 4742:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 4743:};
        -: 4744:
        -: 4745:template <class _Tp>
        -: 4746:struct __has_operator_addressof_free_imp
        -: 4747:{
        -: 4748:    template <class _Up>
        -: 4749:        static auto __test(int)
        -: 4750:            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;
        -: 4751:    template <class>
        -: 4752:        static auto __test(long) -> false_type;
        -: 4753:
        -: 4754:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 4755:};
        -: 4756:
        -: 4757:template <class _Tp>
        -: 4758:struct __has_operator_addressof
        -: 4759:    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
        -: 4760:                                  || __has_operator_addressof_free_imp<_Tp>::value>
        -: 4761:{};
        -: 4762:
        -: 4763:#endif  // _LIBCPP_CXX03_LANG
        -: 4764:
        -: 4765:#if _LIBCPP_STD_VER > 14
        -: 4766:
        -: 4767:template <class...> using void_t = void;
        -: 4768:
        -: 4769:# ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 4770:template <class... _Args>
        -: 4771:struct conjunction : __and_<_Args...> {};
        -: 4772:template<class... _Args>
        -: 4773:_LIBCPP_INLINE_VAR constexpr bool conjunction_v
        -: 4774:    = conjunction<_Args...>::value;
        -: 4775:
        -: 4776:template <class... _Args>
        -: 4777:struct disjunction : __or_<_Args...> {};
        -: 4778:template<class... _Args>
        -: 4779:_LIBCPP_INLINE_VAR constexpr bool disjunction_v
        -: 4780:    = disjunction<_Args...>::value;
        -: 4781:
        -: 4782:template <class _Tp>
        -: 4783:struct negation : __not_<_Tp> {};
        -: 4784:template<class _Tp>
        -: 4785:_LIBCPP_INLINE_VAR constexpr bool negation_v
        -: 4786:    = negation<_Tp>::value;
        -: 4787:# endif // _LIBCPP_HAS_NO_VARIADICS
        -: 4788:#endif  // _LIBCPP_STD_VER > 14
        -: 4789:
        -: 4790:// These traits are used in __tree and __hash_table
        -: 4791:#ifndef _LIBCPP_CXX03_LANG
        -: 4792:struct __extract_key_fail_tag {};
        -: 4793:struct __extract_key_self_tag {};
        -: 4794:struct __extract_key_first_tag {};
        -: 4795:
        -: 4796:template <class _ValTy, class _Key,
        -: 4797:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -: 4798:struct __can_extract_key
        -: 4799:    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
        -: 4800:                  __extract_key_fail_tag>::type {};
        -: 4801:
        -: 4802:template <class _Pair, class _Key, class _First, class _Second>
        -: 4803:struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
        -: 4804:    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
        -: 4805:                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
        -: 4806:
        -: 4807:// __can_extract_map_key uses true_type/false_type instead of the tags.
        -: 4808:// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
        -: 4809:// and _ValTy == _Key.
        -: 4810:template <class _ValTy, class _Key, class _ContainerValueTy,
        -: 4811:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -: 4812:struct __can_extract_map_key
        -: 4813:    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};
        -: 4814:
        -: 4815:// This specialization returns __extract_key_fail_tag for non-map containers
        -: 4816:// because _Key == _ContainerValueTy
        -: 4817:template <class _ValTy, class _Key, class _RawValTy>
        -: 4818:struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
        -: 4819:    : false_type {};
        -: 4820:
        -: 4821:#endif
        -: 4822:
        -: 4823:#if _LIBCPP_STD_VER > 17
        -: 4824:enum class endian
        -: 4825:{
        -: 4826:    little = 0xDEAD,
        -: 4827:    big    = 0xFACE,
        -: 4828:#if defined(_LIBCPP_LITTLE_ENDIAN)
        -: 4829:    native = little
        -: 4830:#elif defined(_LIBCPP_BIG_ENDIAN)
        -: 4831:    native = big
        -: 4832:#else
        -: 4833:    native = 0xCAFE
        -: 4834:#endif
        -: 4835:};
        -: 4836:#endif
        -: 4837:
        -: 4838:_LIBCPP_END_NAMESPACE_STD
        -: 4839:
        -: 4840:#if _LIBCPP_STD_VER > 14
        -: 4841:// std::byte
        -: 4842:namespace std  // purposefully not versioned
        -: 4843:{
        -: 4844:template <class _Integer>
        -: 4845:  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
        -: 4846:  operator<<=(byte& __lhs, _Integer __shift) noexcept
        -: 4847:  { return __lhs = __lhs << __shift; }
        -: 4848:
        -: 4849:template <class _Integer>
        -: 4850:  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
        -: 4851:  operator<< (byte  __lhs, _Integer __shift) noexcept
        -: 4852:  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }
        -: 4853:
        -: 4854:template <class _Integer>
        -: 4855:  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
        -: 4856:  operator>>=(byte& __lhs, _Integer __shift) noexcept
        -: 4857:  { return __lhs = __lhs >> __shift; }
        -: 4858:
        -: 4859:template <class _Integer>
        -: 4860:  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
        -: 4861:  operator>> (byte  __lhs, _Integer __shift) noexcept
        -: 4862:  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }
        -: 4863:
        -: 4864:template <class _Integer>
        -: 4865:  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type
        -: 4866:  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }
        -: 4867:
        -: 4868:}
        -: 4869:#endif
        -: 4870:
        -: 4871:#endif  // _LIBCPP_TYPE_TRAITS
